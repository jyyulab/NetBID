% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipeline_functions.R
\name{generate.masterTable}
\alias{generate.masterTable}
\title{Generate the Master Table for Drivers}
\usage{
generate.masterTable(
  use_comp = NULL,
  DE = NULL,
  DA = NULL,
  target_list = NULL,
  main_id_type = NULL,
  transfer_tab = NULL,
  tf_sigs = tf_sigs,
  z_col = "Z-statistics",
  display_col = c("logFC", "P.Value"),
  column_order_strategy = "type"
)
}
\arguments{
\item{use_comp}{a vector of characters, the name of multiple comparisons. It will be used to name the columns of master table.}

\item{DE}{list, a list of DE comparisons, each comparison is a data.frame. The element name in the list must contain the name in \code{use_comp}.}

\item{DA}{list, a list of DA comparisons, each comparison is a data.frame. The element name in the list must contain the name in \code{use_comp}.}

\item{target_list}{list, a driver-to-target list. The names of the list elements are drivers. Each element is a data frame, usually contains three columns.
"target", target gene names; "MI", mutual information; "spearman", spearman correlation coefficient.
It is highly suggested to follow the NetBID2 pipeline, and the \code{TF_network} could be generated by \code{get_net2target_list} and \code{get.SJAracne.network}.}

\item{main_id_type}{character, the type of driver's ID. It comes from the attribute name in biomaRt package.
Such as "ensembl_gene_id", "ensembl_gene_id_version", "ensembl_transcript_id", "ensembl_transcript_id_version" or "refseq_mrna".
For details, user can call \code{biomaRt::listAttributes()} to display all available attributes in the selected dataset.}

\item{transfer_tab}{data.frame, the data frame for ID conversion. This can be obtained by calling \code{get_IDtransfer}.
If NULL and \code{main_id_type} is not in the column names of \code{tf_sigs}, it will use the conversion table within the function.
Default is NULL.}

\item{tf_sigs}{list, contains all the detailed information of TF and Sig. Users can call \code{db.preload} for access.}

\item{z_col}{character, name of the column in \code{DE} and \code{DA} contains the Z statistics. Default is "Z-statistics".}

\item{display_col}{character, name of the column in \code{DE} and \code{DA} need to be kept in the master table. Default is c("logFC","P.Value").}

\item{column_order_strategy}{character, users can choose between "type" and "comp". Default is "type".
If set as type, the columns will be ordered by column type; If set as comp, the columns will be ordered by comparison.}
}
\value{
Return a data frame contains the mega information of all tested drivers.
The column "originalID" and "originalID_label" is the same ID as from the original dataset.
}
\description{
\code{generate.masterTable} generates a master table to show the mega information of all tested drivers.
}
\details{
The master table gathers TF (transcription factor) information, Sig (signaling factor) information, all the DE (differential expression analysis)
and DA (differential activity analysis) from multiple comparisons. It also shows each driver's target gene size and other additional information
(e.g. gene biotype, chromosome name, position etc.).
}
\examples{
analysis.par <- list()
analysis.par$out.dir.DATA <- system.file('demo1','driver/DATA/',package = "NetBID2")
NetBID.loadRData(analysis.par=analysis.par,step='ms-tab')
#analysis.par$final_ms_tab ## this is master table generated before
ac_mat <- cal.Activity(target_list=analysis.par$merge.network$target_list,
                       cal_mat=Biobase::exprs(analysis.par$cal.eset),es.method='weightedmean')
analysis.par$ac.merge.eset  <- generate.eset(exp_mat=ac_mat,
                                             phenotype_info=Biobase::pData(analysis.par$cal.eset))
phe_info <- Biobase::pData(analysis.par$cal.eset)
all_subgroup <- base::unique(phe_info$subgroup) ##
for(each_subtype in all_subgroup){
 comp_name <- sprintf('\%s.Vs.others',each_subtype) ## each comparison must give a name !!!
 G0  <- rownames(phe_info)[which(phe_info$`subgroup`!=each_subtype)] # get sample list for G0
 G1  <- rownames(phe_info)[which(phe_info$`subgroup`==each_subtype)] # get sample list for G1
 DE_gene_limma <- getDE.limma.2G(eset=analysis.par$cal.eset,G1=G1,G0=G0,
                                 G1_name=each_subtype,G0_name='other')
 analysis.par$DE[[comp_name]] <- DE_gene_limma
 DA_driver_limma <- getDE.limma.2G(eset=analysis.par$ac.merge.eset,G1=G1,G0=G0,
                                   G1_name=each_subtype,G0_name='other')
 analysis.par$DA[[comp_name]] <- DA_driver_limma
}
all_comp <- names(analysis.par$DE) ## get all comparison name for output
db.preload(use_level='gene',use_spe='human',update=FALSE);
test_ms_tab <- generate.masterTable(use_comp=all_comp,
                                           DE=analysis.par$DE,
                                           DA=analysis.par$DA,
                                           target_list=analysis.par$merge.network$target_list,
                                           tf_sigs=tf_sigs,
                                           z_col='Z-statistics',
                                           display_col=c('logFC','P.Value'),
                                           main_id_type='external_gene_name')
}
