---
title: "QC plot for network generated by SJAracne"
output: 
  html_document
---

```{r include=FALSE}
library(NetBID2)
library(kableExtra)
```

```{r echo=FALSE}
deg <- igraph::degree(net,mode='out')
source_list <- names(deg)[which(deg>0)]
full_info <- FALSE
if(html_info_limit==FALSE) full_info<-TRUE
c1 <- components(net)
if(weighted==TRUE) edge_weight <- E(net)$weight else edge_weight<-NULL
```


## Part I: Basic statistics

This network is `r ifelse(directed==TRUE,'a directed','an undirected')` and `r ifelse(weighted==TRUE,'weighted','unweighted')` network, 
which contains `r length(V(net))` nodes and `r length(E(net))` edges.
This network contains `r c1$no` connected components, in which the largest component size is `r c1$csize`.
In total `r length(source_list)` nodes are possible drivers.


```{r include=FALSE}
net_statistic <- list()
net_detail    <- list()

## global network
net_statistic$edge_density <- igraph::edge_density(net, loops=F);  ## The density of a graph is the ratio of the number of edges and the number of possible edges.
if(full_info==TRUE) net_statistic$diameter <- igraph::diameter(net, directed=directed, weights=edge_weight) ## The diameter of a graph is the length of the longest geodesic.
if(full_info==TRUE) net_statistic$mean_distance <- igraph::mean_distance(net,directed=directed)
  
## nodes
# degree
if(directed==TRUE) c1 <- igraph::degree(net, mode="out", normalized=FALSE) ## Centralize a graph according to the degrees of vertices
if(directed==TRUE) c2 <- igraph::degree(net, mode="in", normalized=FALSE) ## Centralize a graph according to the degrees of vertices
c3 <- igraph::degree(net, mode="all", normalized=FALSE) ## Centralize a graph according to the degrees of vertices
if(directed==TRUE) net_detail$degree_out <- c1
if(directed==TRUE) net_detail$degree_in  <- c2
net_detail$degree_all <- c3

# centralized degree
if(directed==TRUE) c1 <- igraph::centr_degree(net, mode="out", normalized=TRUE) ## Centralize a graph according to the degrees of vertices
if(directed==TRUE) c2 <- igraph::centr_degree(net, mode="in", normalized=TRUE) ## Centralize a graph according to the degrees of vertices
c3 <- igraph::centr_degree(net, mode="all", normalized=TRUE) ## Centralize a graph according to the degrees of vertices
if(directed==TRUE) net_statistic$degree_out_centrality <- c1$centralization
if(directed==TRUE) net_statistic$degree_in_centrality  <- c2$centralization
net_statistic$degree_all_centrality <- c3$centralization

# Closeness centrality of vertices
if(full_info==TRUE){
  if(directed==TRUE) c1 <- igraph::centr_clo(net,mode='out')
  if(directed==TRUE) c2 <- igraph::centr_clo(net,mode='in')
  c3 <- igraph::centr_clo(net,mode='all')
  if(directed==TRUE) net_statistic$closeness_out_centrality <- c1$centralization
  if(directed==TRUE) net_statistic$closeness_in_centrality  <- c2$centralization
  net_statistic$closeness_all_centrality <- c3$centralization 
  if(directed==TRUE) net_detail$centr_closeness_out <- c1$res
  if(directed==TRUE) net_detail$centr_closeness_in  <- c2$res
  net_detail$centr_closeness_all <- c3$res
}

# Find Eigenvector Centrality Scores of Network Positions
c1 <- igraph::eigen_centrality(net,directed=directed,weights = edge_weight)
net_statistic$eigen_centrality_scores <- c1$value # The eigenvalue corresponding to the calculated eigenvector, i.e. the centrality scores.
net_detail$eigen_centrality_scores <- c1$vector

# Centralize a graph according to the eigenvector centrality of vertices
c1 <- igraph::centr_eigen(net,directed=directed,normalized = TRUE)
net_statistic$eigen_centrality <- c1$centralization # The graph level centrality index.
net_detail$eigen_centrality <- c1$vector

# Vertex and edge betweenness centrality
#c1 <- betweenness(net,directed=directed,weights = edge_weight)
#net_detail$vertex_betweenness <- c1
if(full_info==TRUE){
  c1 <- igraph::centr_betw(net, directed=directed, normalized=TRUE)
  net_statistic$betweenness_centrality <- c1$centralization # The graph level centrality index.
  net_detail$betweenness_centrality <- c1$res
}

# hub score
c1 <- igraph::hub_score(net,weights=edge_weight)
net_statistic$hub_centrality <- c1$value # The hub scores of the vertices are defined as the principal eigenvector of A*t(A), where A is the adjacency matrix of the graph.
net_detail$hub_centrality <- c1$vector

# pagerank
c1 <- igraph::page_rank(net,directed=directed,weights = edge_weight) # Calculates the Google PageRank for the specified vertices.
net_statistic$page_rank_score <- c1$value # The graph level centrality index.
net_detail$page_rank_score <- c1$vector

## edges
#net_edge_detail <- list()
#c1 <- edge_betweenness(net,directed=directed,weights = edge_weight)
#names(c1) <- attr(E(net),'vnames')
#net_edge_detail$edge_betweenness <- c1

dt <- as.data.frame(unlist(net_statistic))
colnames(dt) <- 'Value'
dt$Note <- NULL
if('edge_density' %in% rownames(dt))dt['edge_density','Note'] <- 'the ratio of the number of edges and the number of possible edges';
if('diameter' %in% rownames(dt))dt['diameter','Note'] <- 'the length of the longest geodesic';
if('mean_distance' %in% rownames(dt))dt['mean_distance','Note'] <- 'the average path length in a graph, by calculating the shortest paths between all pairs of vertices (both ways for directed graphs)';

if('degree_out_centrality' %in% rownames(dt)) dt['degree_out_centrality','Note'] <- 'the graph level centrality index according to the out degrees of vertices';
if('degree_in_centrality' %in% rownames(dt)) dt['degree_in_centrality','Note'] <- 'the graph level centrality index according to the in degrees of vertices';
if('degree_all_centrality' %in% rownames(dt))dt['degree_all_centrality','Note'] <- 'the graph level centrality index according to the all degrees of vertices';

if('closeness_out_centrality' %in% rownames(dt)) dt['closeness_out_centrality','Note'] <- 'the graph level centrality index according to the closeness of vertices (out mode)';
if('closeness_in_centrality' %in% rownames(dt)) dt['closeness_in_centrality','Note'] <- 'the graph level centrality index according to the closeness of vertices (in mode)';
if('closeness_all_centrality' %in% rownames(dt))dt['closeness_all_centrality','Note'] <- 'the graph level centrality index according to the closeness of vertices';

if('eigen_centrality_scores' %in% rownames(dt))dt['eigen_centrality_scores','Note'] <- 'the ratio of the number of edges and the number of possible edges';
if('eigen_centrality' %in% rownames(dt))dt['eigen_centrality','Note'] <- 'the eigenvector centralities';
if('betweenness_centrality' %in% rownames(dt))dt['betweenness_centrality','Note'] <- 'the graph level centrality index according to the betweenness of vertices';
if('hub_centrality' %in% rownames(dt))dt['hub_centrality','Note'] <- 'the principal eigenvector of A*t(A), where A is the adjacency matrix of the graph';
if('page_rank_score' %in% rownames(dt))dt['page_rank_score','Note'] <- 'the graph level centrality index according to the Google PageRank';
```

```{r echo=FALSE}
kableExtra::kable(dt,align = "c") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  kableExtra::scroll_box(width = "100%", height = "100%")
```

## Part II: Detailed statistics for drivers

Detailed statistics for all `r length(source_list)` drivers. 

```{r echo=FALSE}
dt <- do.call(cbind,net_detail)
dt1 <- dt[source_list,]
if(class(dt1)[1]=='numeric'){dt1 <- t(as.matrix(dt1)); colnames(dt1) <- colnames(dt); rownames(dt1) <- source_list}
if(nrow(dt1)<20){
kableExtra::kable(dt1,align = "c") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  kableExtra::scroll_box(width = "100%", height = "100%")
}else{
  kableExtra::kable(dt1,align = "c") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
}

```

## Part III: Drirver's target size checking

```{r echo=FALSE, fig.width=8, fig.height=8}
par(mar=c(6,6,6,8))
d_out <- igraph::degree(net,mode = 'all')
a <- hist(d_out,breaks = 20,xlab='Degree',cex.lab=1.2,cex.axis=1.2,cex.main=1.2,
     main=sprintf('Density plot of degree distribution for all nodes \n (network node:%d, network edge:%d)',length(V(net)),length(E(net))));
d1 <- density(d_out)
mm <- max(a$counts)/max(d1$y);mm1 <- seq(0,max(d1$y),length.out = 5);mm2 <- format(mm1,scientific=TRUE,digits=3);mm2[1]<-'0';
lines(x=d1$x,y=d1$y*mm,col=get_transparent('red',0.5),lwd=1.5)
axis(side=4,at=mm*mm1,labels=mm2,las=2);
mtext(side=4,line = 6,'Density',cex=1.2)
#
d_out <- igraph::degree(net,mode = 'out')[source_list]
if(length(d_out)>10){
  a <- hist(d_out,breaks = 20,xlab='Degree',cex.lab=1.2,cex.axis=1.2,cex.main=1.2,
     main=sprintf('Density plot of target size for all %s drivers \n (Size from %s to %s; mean Size: %s, median Size: %s )',length(source_list),min(d_out),max(d_out),format(mean(d_out),digits=5),median(d_out)));
d1 <- density(d_out)
mm <- max(a$counts)/max(d1$y);mm1 <- seq(0,max(d1$y),length.out = 5);mm2 <- format(mm1,scientific=TRUE,digits=3);mm2[1]<-'0';
lines(x=d1$x,y=d1$y*mm,col=get_transparent('red',0.5),lwd=1.5)
axis(side=4,at=mm*mm1,labels=mm2,las=2);
mtext(side=4,line = 6,'Density',cex=1.2)
}else{
  print(d_out)
}
```

## Part IV: Scale free distribution checking

```{r echo=FALSE, fig.width=8, fig.height=8}
check_scalefree <- function(igraph_obj) {
  gr1 <- igraph_obj
  fp1 <- igraph::degree_distribution(gr1)
  dd <- as.data.frame(cbind(k = 1:max(igraph::degree(gr1)), pk = fp1[-1]))
  dd$pk <- dd$pk + 1 / length(V(gr1))
  r2 <-
    lm(log10(dd$pk) ~ log10(dd$k))
  r3 <- summary(r2)$adj.r.squared
  if(length(dd$k)>100) plot(pk ~ k,data = dd,log = 'xy',main = sprintf('R2:%s', format(r3,digits=4)),pch=16,col=get_transparent('dark grey',0.8),cex.lab=1.4,cex.axis=1.2)
  if(length(dd$k)<=100) plot(pk ~ k,data = dd,log = 'xy',main = sprintf('R2:%s', format(r3,digits=4)),pch=16,col=get_transparent('black',0.8),cex.lab=1.4,cex.axis=1.2)
  abline(a=r2$coefficients[1],b=r2$coefficients[2],col=get_transparent('red',0.5),lwd=2)
  return(r3)
}
res1 <- check_scalefree(net)
```



