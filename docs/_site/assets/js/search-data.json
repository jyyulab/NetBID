{
  "0": {
    "id": "0",
    "title": "Navigation&FAQ",
    "content": "Navigation &amp; FAQ Network Construction Step 0: Preparations Step 1: Load in gene expression datasets for network construction (exp-load) Q&amp;A: The choice of expression dataset for network construction Q&amp;A: Input RNA-Seq dataset Q&amp;A: Input expression matrix not from GEO database Step 2: Normalization for the expression dataset (exp-QC) Q&amp;A: QC for RNA-Seq dataset Q&amp;A: Combine two datasets Step 3: Check sample cluster information, optional (exp-cluster) Step 4: Prepare files to run SJARACNe (sjaracne-prep) Q&amp;A: ID conversion Driver Estimation Step 0: Preparations Step 1: Load in the expression dataset for analysis (exp-load, exp-cluster, exp-QC) Q&amp;A: What to do if the ID types from network-construction dataset and analysis dataset are different? Step 2: Read in network files and calcualte driver activity (act-get) Q&amp;A: Why study driver’s activity ? Step 3: Get differential expression (DE) / differential activity (DA) for drivers (act-DA) Step 4: Generate a master table for drivers (ms-tab) Q&amp;A: How to interpret and use the master table ? Advanced analysis Preparations Part I: More details about the top drivers QI.1: How to get the top drivers with significant differential activity (DA) in the comparison between G4 vs. other subtypes ? QI.2: How to interpret the significance of top DA drivers ? QI.3: What is the expression/activity pattern of these top DA drivers across sample subtypes? QI.4: What are the biological functions of these top DA drivers ? QI.5: What are the biological functions of the target genes of these top DA drivers ? Part II: More details about the selected driver QII.1: How to interpret the significance of the selected driver ? QII.2: How to visualize the network structure of the selected driver ? QII.3: What is the expression/activity of this selected driver across subtypes of sample ? QII.4: What are the functions of the target genes of this selected driver ? Part III: Other analyses NetBID2 can do QIII.1: What are the activities of the curated gene sets across all samples ? QIII.2: How to find drivers share significantly overlapped target genes ? Q&amp;A: How to modify the figure size created by draw. functions ?",
    "url": "http://localhost:4000/docs/QA",
    "relUrl": "/docs/QA"
  },
  "1": {
    "id": "1",
    "title": "About",
    "content": "About the project For the detailed description of NetBID algorithm, please check our lab page View Yu Lab@St. Jude. Contact Email: xinran.dong@foxmail.com jiyang.yu@stjude.org Citation License Apache 2.0. Copyright © 2017 - 2019 St. Jude Children’s Research Hospital",
    "url": "http://localhost:4000/docs/about",
    "relUrl": "/docs/about"
  },
  "2": {
    "id": "2",
    "title": "- Advanced analysis",
    "content": "Advanced analysis and visualization The purpose of this part: further analysis and visualization of the significant drivers. One “lazy mode” function without flexiable options is available for this part of analysis: NetBID.lazyMode.DriverVisualization(). User could check the manual for this function and try the demo code for usage. The complete step-by-step demo script for result visualization can be found here, analysis_and_plot_demo1.R. From the demo dataset, we’ve found the significant hidden drivers in Group4 compared to other subtype groups. These drivers may relate to specific clinical features of the adult medulloblastoma Group4, and hence the further investigation is needed. Here, we’ve listed some important biological questions which can be further investigated using NetBID2. Quick Navigation for this page Preparations Part I: More details about the top drivers QI.1: How to get the top drivers with significant differential activity (DA) in the comparison between G4 vs. other subtypes ? QI.2: How to interpret the significance of top DA drivers ? QI.3: What is the expression/activity pattern of these top DA drivers across sample subtypes? QI.4: What are the biological functions of these top DA drivers ? QI.5: What are the biological functions of the target genes of these top DA drivers ? Part II: More details about the selected driver QII.1: How to interpret the significance of the selected driver ? QII.2: How to visualize the network structure of the selected driver ? QII.3: What is the expression/activity of this selected driver across subtypes of sample ? QII.4: What are the functions of the target genes of this selected driver ? Part III: Other analyses NetBID2 can do QIII.1: What are the activities of the curated gene sets across all samples ? QIII.2: How to find drivers share significantly overlapped target genes ? Q&amp;A: How to modify the figure size created by draw. functions ? Preparations Make sure you have NetBID2 package. library(NetBID2) Reload previous saved RData from ms-tab step. Here, we use the demo data from NetBID2 package. Users can call analysis.par$out.dir.PLOT to see where the plots created by later pipeline will be saved, this can be modified. # Give file path to reload `ms-tab` RData from driver estimation step analysis.par &lt;- list() # Here we use demo data from NetBID2 package analysis.par$out.dir.DATA &lt;- system.file(&#39;demo1&#39;,&#39;driver/DATA/&#39;,package = &quot;NetBID2&quot;) NetBID.loadRData(analysis.par=analysis.par,step=&#39;ms-tab&#39;) # To see where the plots created later will be saved print(analysis.par$out.dir.PLOT) #analysis.par$out.dir.PLOT &lt;- &#39;test/driver/PLOT&#39; # Users can modify this path Part I: More details about the top drivers QI.1: How to get the top drivers with significant differential activity (DA) in the comparison between G4 vs. other subtypes ? First, retrive the master table element from the analysis.par super list, and pass it to a new variable ms_tab. Filter out drivers with target size too small (e.g. &lt;30) and too big (e.g. &gt;1000). Define the comparison name comp_name as G4.Vs.others. ms_tab &lt;- analysis.par$final_ms_tab ## get the master table data frame ms_tab &lt;- ms_tab[which(ms_tab$Size&gt;=30 &amp; ms_tab$Size &lt;=1000),] comp_name &lt;- &#39;G4.Vs.others&#39; ## get the comparison name To quickly identify top DA drivers from large dataset, NetBID2 uses the volcano plot draw.volcanoPlot(). In this special scatter-plot, the y axis shows the significance of DA driver, the x axis shos the fold-change. More handlers of draw.volcanoPlot(): Input data frame must contain columns of label_col, logFC_col and Pv_col. To set thresholds, please use logFC_thre (for logFC) and Pv_thre (for P-value). To turn off figure display, only return the top driver list, please set show_plot=FALSE. To show driver labels that passed the threshold only, please set show_label=TRUE. If one set std=TRUE to cal.Activity(), the threshold of logFC of the activity value should not be set very high. The figure below is to show the top DA drivers passed the thresholds of logFC≥0.4 and P-value≤1e-8. sig_driver &lt;- draw.volcanoPlot(dat=ms_tab,label_col=&#39;gene_label&#39;,logFC_col=sprintf(&#39;logFC.%s_DA&#39;,comp_name), Pv_col=sprintf(&#39;P.Value.%s_DA&#39;,comp_name),logFC_thre=0.4,Pv_thre=1e-8, main=sprintf(&#39;Volcano Plot for %s_DA&#39;,comp_name),show_label=TRUE, pdf_file=sprintf(&#39;%s/vocalno_label_DA.pdf&#39;,analysis.par$out.dir.PLOT),label_cex = 1) draw.volcanoPlot() is also applicable visualize the top DE genes. The figure below are top genes with DE passed thresholds of logFC≥1.5 and P-value≤1e-4. sig_gene &lt;- draw.volcanoPlot(dat=ms_tab,label_col=&#39;geneSymbol&#39;,logFC_col=sprintf(&#39;logFC.%s_DE&#39;,comp_name), Pv_col=sprintf(&#39;P.Value.%s_DE&#39;,comp_name),logFC_thre=1.5,Pv_thre=1e-4, main=sprintf(&#39;Volcano Plot for %s_DE&#39;,comp_name),show_label=TRUE, pdf_file=sprintf(&#39;%s/vocalno_label_DE.pdf&#39;,analysis.par$out.dir.PLOT),label_cex = 1) The returned sig_driver and sig_gene are the data frames containing drivers and genes that passed the thresholds. QI.2: How to interpret the significance of top DA drivers ? A driver’s activity is evaluated from the expression pattern of its target genes. Due to this, if a driver’s activity value is significantly up-regulated in G4 compared to other subtypes, it can be caused by two ways: (a) its positively-regulated target genes have significantly upregulation in G4 compared to others; (b) its negatively-regulated target genes have significantly downregulation in G4 compared to others. draw.GSEA.NetBID() helps users to interpret the significance of these top DA drivers from the expression and regulation of their target genes. First, get the differential expression (DE) data frame of the target genes from the comparison between Group4 vs. others. Here, we need to pay attention to the gene ID type. The ID type should be the originalID_label column from the master table. The same ID type we used to draw the volcano plot. # Get the DE data frame of target genes DE &lt;- analysis.par$DE[[comp_name]] driver_list &lt;- rownames(sig_driver) # The rownames is the originalID_label The following 5 figures are showing the same content. The purpose is to list various visualizations that draw.GSEA.NetBID() can provide. The key handlers are profile_trend, profile_col, target_nrow, target_col and target_col_type. In the first demo plot below, the top figure is a metric for the ranking of genes based on their logFC values (profile_col). The order of ranking is from negative values to positive values (profile_trend=&#39;neg2pos&#39;). The bottom figure has three parts: on the left is a horizontal barplot showing the target size of up-regulated and down-regulated genes for each driver; in the middle are panels marking each target gene’s ranking position (panel number for each driver can be 1 or 2, here target_nrow=2), and the name of the color palette used for display target genes marker lines is target_col_type=&#39;DE&#39;; on the right is the DA and DE values for each driver (using threhold profile_sig_thre, blue is negative, red is positive). From the figure below, we can see the positively-regulated target genes of the down DA drivers tend to have lower logFC expression values in G4 compared to other subtypes. For the up DA drivers, it shows the opposite. For example, GALNT4_SIG driver has a significantly negative activity value in G4 compared to other subtypes (marked in blue, P-value is 1e-09). It has around 160 positively-regulated target genes (orange bar on the left), and most of their logFC are negative values with high rankings (first panel with blue and grey marker lines). It means these positively-regulated target genes have significant negative logFC values in G4 compared to other subtypes. Vice versa for the negatively-regulated target genes. These two expression patterns of target genes contribute to their driver’s DA value. draw.GSEA.NetBID(DE=DE,profile_col=&#39;logFC&#39;,profile_trend=&#39;neg2pos&#39;,name_col=&#39;ID&#39;, driver_list = driver_list, show_label=ms_tab[driver_list,&#39;gene_label&#39;], driver_DA_Z=ms_tab[driver_list,sprintf(&#39;Z.%s_DA&#39;,comp_name)], driver_DE_Z=ms_tab[driver_list,sprintf(&#39;Z.%s_DE&#39;,comp_name)], target_list=analysis.par$merge.network$target_list, top_driver_number=30,target_nrow=2,target_col=&#39;RdBu&#39;, left_annotation = &#39;high in others&#39;,right_annotation = &#39;high in G4&#39;, main=comp_name,target_col_type=&#39;DE&#39;,Z_sig_thre=1.64,profile_sig_thre = 1.64, pdf_file=sprintf(&#39;%s/NetBID_GSEA_demo1.pdf&#39;,analysis.par$out.dir.PLOT)) In the second demo plot below, the top figure is a metric for the ranking of genes based on their t values (profile_col). The order of ranking is from positive values to negative values (profile_trend=&#39;pos2neg&#39;). The name of the color palette used for display target genes marker lines is target_col_type=&#39;PN&#39;. draw.GSEA.NetBID(DE=DE,profile_col=&#39;t&#39;,profile_trend=&#39;pos2neg&#39;, driver_list = driver_list, show_label=ms_tab[driver_list,&#39;gene_label&#39;], driver_DA_Z=ms_tab[driver_list,sprintf(&#39;Z.%s_DA&#39;,comp_name)], driver_DE_Z=ms_tab[driver_list,sprintf(&#39;Z.%s_DE&#39;,comp_name)], target_list=analysis.par$merge.network$target_list, top_driver_number=30,target_nrow=2,target_col=&#39;RdBu&#39;, left_annotation = &#39;high in G4&#39;,right_annotation = &#39;high in others&#39;, main=comp_name,target_col_type=&#39;PN&#39;,Z_sig_thre=1.64,profile_sig_thre = 1.64, pdf_file=sprintf(&#39;%s/NetBID_GSEA_demo2.pdf&#39;,analysis.par$out.dir.PLOT)) In the third demo plot below, the color used to mark those target genes is black (target_col=&#39;black&#39;). draw.GSEA.NetBID(DE=DE,profile_col=&#39;t&#39;,profile_trend=&#39;pos2neg&#39;, driver_list = driver_list, show_label=ms_tab[driver_list,&#39;gene_label&#39;], driver_DA_Z=ms_tab[driver_list,sprintf(&#39;Z.%s_DA&#39;,comp_name)], driver_DE_Z=ms_tab[driver_list,sprintf(&#39;Z.%s_DE&#39;,comp_name)], target_list=analysis.par$merge.network$target_list, top_driver_number=30,target_nrow=2,target_col=&#39;black&#39;, left_annotation = &#39;high in G4&#39;,right_annotation = &#39;high in others&#39;, main=comp_name,target_col_type=&#39;PN&#39;,Z_sig_thre=1.64,profile_sig_thre = 1.64, pdf_file=sprintf(&#39;%s/NetBID_GSEA_demo3.pdf&#39;,analysis.par$out.dir.PLOT)) In the forth demo plot below, the number of panels to mark each target gene’s ranking position is 1, target_nrow=1. User can set target_col=&#39;RdBu&#39; and target_col_type=&#39;DE&#39; to distinguish positively-regulated target genes from negatively-regulated target genes. draw.GSEA.NetBID(DE=DE,profile_col=&#39;t&#39;,profile_trend=&#39;pos2neg&#39;, driver_list = driver_list, show_label=ms_tab[driver_list,&#39;gene_label&#39;], driver_DA_Z=ms_tab[driver_list,sprintf(&#39;Z.%s_DA&#39;,comp_name)], driver_DE_Z=ms_tab[driver_list,sprintf(&#39;Z.%s_DE&#39;,comp_name)], target_list=analysis.par$merge.network$target_list, top_driver_number=30,target_nrow=1,target_col=&#39;RdBu&#39;, left_annotation = &#39;high in G4&#39;,right_annotation = &#39;high in others&#39;, main=comp_name,target_col_type=&#39;DE&#39;,Z_sig_thre=1.64,profile_sig_thre = 1.64, pdf_file=sprintf(&#39;%s/NetBID_GSEA_demo4.pdf&#39;,analysis.par$out.dir.PLOT)) In the fifth demo plot below, the number of panels to mark each target gene’s ranking position is 1, target_nrow=1. And all the target genes marker lines are black, target_col=&#39;black&#39;. draw.GSEA.NetBID(DE=DE,profile_col=&#39;t&#39;,profile_trend=&#39;pos2neg&#39;, driver_list = driver_list, show_label=ms_tab[driver_list,&#39;gene_label&#39;], driver_DA_Z=ms_tab[driver_list,sprintf(&#39;Z.%s_DA&#39;,comp_name)], driver_DE_Z=ms_tab[driver_list,sprintf(&#39;Z.%s_DE&#39;,comp_name)], target_list=analysis.par$merge.network$target_list, top_driver_number=30,target_nrow=1,target_col=&#39;black&#39;, left_annotation = &#39;high in G4&#39;,right_annotation = &#39;high in others&#39;, main=comp_name,target_col_type=&#39;PN&#39;,Z_sig_thre=1.64,profile_sig_thre = 1.64, pdf_file=sprintf(&#39;%s/NetBID_GSEA_demo5.pdf&#39;,analysis.par$out.dir.PLOT)) QI.3: What is the expression/activity pattern of these top DA drivers across sample subtypes? Next, we’d like to know the expression/activity pattern of these top DA drivers from different sample subtypes. In NetBID2, draw.heatmap() is designed to assist this using user-friendly heatmap. It is based on Heatmap() function in ComplexHeatmap. First, please get the expression matrix exp_mat, the activity matrix ac_mat and the phenotype data frame phe_info from analysis.par super list. exp_mat &lt;- exprs(analysis.par$cal.eset) # expression matrix, the rownames must be the originalID ac_mat &lt;- exprs(analysis.par$merge.ac.eset) # activity matrix, the rownames must be the originalID_label phe_info &lt;- pData(analysis.par$cal.eset) # phenotype data frame Draw the heatmap using expression value of top DA drivers (scaled by samples scale=&#39;row&#39;). Here, the use_genes must be the originalID. Here, we displayed all the phenotype columns: gender, pathology, subgroup and age. Users can assign phenotype_info=phe_info and choose specific phenotype column(s) to display using use_phe. draw.heatmap(mat=exp_mat,use_genes=ms_tab[driver_list,&#39;originalID&#39;],use_gene_label=ms_tab[driver_list,&#39;geneSymbol&#39;], use_samples=colnames(exp_mat),use_sample_label=phe_info[colnames(exp_mat),&#39;geo_accession&#39;], phenotype_info=phe_info,use_phe=c(&#39;gender&#39;,&#39;pathology&#39;,&#39;subgroup&#39;,&#39;age&#39;),main=&#39;Expression for Top drivers&#39;,scale=&#39;row&#39;, cluster_rows=TRUE,cluster_columns=TRUE,clustering_distance_rows=&#39;pearson&#39;,clustering_distance_columns=&#39;pearson&#39;, row_names_gp = gpar(fontsize = 12),pdf_file=sprintf(&#39;%s/heatmap_demo1.pdf&#39;,analysis.par$out.dir.PLOT), pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) Draw the heatmap using activity value of top DA drivers. Here, the use_genes must be the originalID_label. But user can also use the label in the gene_label column for display. In the demo, the original label is gene symbol. But in some cases, the original label can be the ensemble_gene_id, then the originalID will be different. In this case, user can choose the gene symbol in gene_label (set by use_gene_label) for display. draw.heatmap(mat=ac_mat,use_genes=driver_list,use_gene_label=ms_tab[driver_list,&#39;gene_label&#39;], use_samples=colnames(exp_mat),use_sample_label=phe_info[colnames(exp_mat),&#39;geo_accession&#39;], phenotype_info=phe_info,use_phe=c(&#39;gender&#39;,&#39;pathology&#39;,&#39;subgroup&#39;,&#39;age&#39;),main=&#39;Activity for Top drivers&#39;,scale=&#39;row&#39;, cluster_rows=TRUE,cluster_columns=TRUE,clustering_distance_rows=&#39;pearson&#39;,clustering_distance_columns=&#39;pearson&#39;, row_names_gp = gpar(fontsize = 12),pdf_file=sprintf(&#39;%s/heatmap_demo2.pdf&#39;,analysis.par$out.dir.PLOT), pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) Now, we compare the two heatmaps we created using the expression matrix and the activity matrix of top DA drivers. As we can see, the activity matrix gives a much cleaner pattern than the expression matrix. Same observation from the top DE drivers. Figures not shown below, but users can use the script below to check. This observation highly suggested the activity value of driver may be more robust than expression value in sample classification. # Draw heatmaps using top DE genes gene_list &lt;- rownames(sig_gene) draw.heatmap(mat=exp_mat,use_genes=ms_tab[gene_list,&#39;originalID&#39;],use_gene_label=ms_tab[gene_list,&#39;geneSymbol&#39;], use_samples=colnames(exp_mat),use_sample_label=phe_info[colnames(exp_mat),&#39;geo_accession&#39;], phenotype_info=phe_info,use_phe=c(&#39;gender&#39;,&#39;pathology&#39;,&#39;subgroup&#39;,&#39;age&#39;),main=&#39;Expression for Top drivers&#39;,scale=&#39;row&#39;, cluster_rows=TRUE,cluster_columns=TRUE,clustering_distance_rows=&#39;pearson&#39;,clustering_distance_columns=&#39;pearson&#39;, row_names_gp = gpar(fontsize = 12),pdf_file=sprintf(&#39;%s/heatmap_demo3.pdf&#39;,analysis.par$out.dir.PLOT), pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) draw.heatmap(mat=ac_mat,use_genes= gene_list,use_gene_label=ms_tab[gene_list,&#39;gene_label&#39;], use_samples=colnames(exp_mat),use_sample_label=phe_info[colnames(exp_mat),&#39;geo_accession&#39;], phenotype_info=phe_info,use_phe=c(&#39;gender&#39;,&#39;pathology&#39;,&#39;subgroup&#39;,&#39;age&#39;),main=&#39;Activity for Top drivers&#39;,scale=&#39;row&#39;, cluster_rows=TRUE,cluster_columns=TRUE,clustering_distance_rows=&#39;pearson&#39;,clustering_distance_columns=&#39;pearson&#39;, row_names_gp = gpar(fontsize = 12),pdf_file=sprintf(&#39;%s/heatmap_demo4.pdf&#39;,analysis.par$out.dir.PLOT), pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) QI.4: What are the biological functions of these top DA drivers ? In order to study the biological functions of these top DA drivers, we need to import the curated gene sets from MSigDB. NetBID2 has provided one function gs.preload() to automatically download curated gene sets from MSigDB (based on msigdbr). Users only need to give a species names as input to the function. All available species names can be found by calling msigdbr_show_species(). By default, the species name is “Homo sapiens”. And NetBID2 has it downloaded in the package already. Similar to db.preload(), if users leave main.dir=NULL, the downloaded data will be save as RData into the followin path, system.file(package = &quot;NetBID2&quot;)/db/. However, if NetBID2 is installed in a public server and user doesn’t root permission, he needs to give accessible path to main.dir. To check the detailed information of the downloaded gene sets, user can use the following scripts. Print all_gs2gene_info from the global variable all_gs2gene. The column Category and Sub-Category will be used as the label to extract gene sets categories. # Download gene sets from MSigDB and save as RData, creat a global variable all_gs2gene gs.preload(use_spe=&#39;Homo sapiens&#39;,update=FALSE) print(all_gs2gene_info) To perform gene set enrichment analysis, NetBID2 provides funcEnrich.Fisher(). Details about how to use funcEnrich.Fisher(): input_list and bg_list must be the gene symbols, which is the geneSymbol column in the master table; gs2gene is a list contains elements of gene sets. The name of the element is gene set, each element contains a vector of genes in that gene set. If NULL, will use all_gs2gene, which is created by function gs.preload(); use_gs is a vector of the names of gene sets, it can be a mixture of Category name and Sub-Category name. Users don’t need to worry about the gene redundant issue, all the gene sets will be handled by merge_gs(), which will merge the redundant information. # Gene Set Enrichment Analysis driver_list_up &lt;- rownames(sig_driver)[which(sig_driver[,2]&gt;0)] # up driver_list_down &lt;- rownames(sig_driver)[which(sig_driver[,2]&lt;0)] # down res_up &lt;- funcEnrich.Fisher(input_list=ms_tab[driver_list_up,&#39;geneSymbol&#39;],bg_list=unique(ms_tab[,&#39;geneSymbol&#39;]),use_gs=c(&#39;H&#39;,&#39;CP:REACTOME&#39;,&#39;BP&#39;,&#39;CGP&#39;), Pv_thre=0.1,Pv_adj = &#39;none&#39;,min_gs_size = 30, max_gs_size = 500) res_down &lt;- funcEnrich.Fisher(input_list=ms_tab[driver_list_down,&#39;geneSymbol&#39;],bg_list=unique(ms_tab[,&#39;geneSymbol&#39;]),use_gs=c(&#39;H&#39;,&#39;CP:REACTOME&#39;,&#39;BP&#39;,&#39;CGP&#39;), Pv_thre=0.1,Pv_adj = &#39;none&#39;,min_gs_size = 30, max_gs_size = 500) funcEnrich.Fisher() uses Fisher’s Exact Test and return detailed results for the gene set enrichment analysis. And the results can be saved as EXCEL file by out2excel(). # Save gene set enrichment analysis results as EXCEl out2excel(list(up=res_up,down=res_down),out.xlsx=sprintf(&#39;%s/fisher_res.xlsx&#39;,analysis.par$out.dir.PLOT)) NetBID2 also designed two functions to visualze the gene set enrichment analysis for these top drivers: draw.funcEnrich.bar() and draw.funcEnrich.cluster(). draw.funcEnrich.bar() draws a horizontal barplot to display the top enriched functions and the corresponding drivers (if set display_genes=TRUE). # Gene set enrichment analysis Barplot draw.funcEnrich.bar(funcEnrich_res= res_up,top_number=30,main=&#39;Function Enrichment for Top drivers&#39;,pdf_file=sprintf(&#39;%s/funcEnrich_bar_nogene.pdf&#39;,analysis.par$out.dir.PLOT)) draw.funcEnrich.bar(funcEnrich_res= res_up,top_number=30,main=&#39;Function Enrichment for Top drivers&#39;,display_genes = TRUE,gs_cex=0.6, pdf_file=sprintf(&#39;%s/funcEnrich_bar_withgene.pdf&#39;,analysis.par$out.dir.PLOT)) Considering the function redundancy of gene sets, users can call draw.funcEnrich.cluster() to cluster genes by their function similarity. # Gene set enrichment analysis Function Cluster Plot draw.funcEnrich.cluster(funcEnrich_res= res_up,top_number=30,gs_cex = 1.4,gene_cex=1.5,pv_cex=1.2,pdf_file = sprintf(&#39;%s/funcEnrich_clusterBOTH.pdf&#39;,analysis.par$out.dir.PLOT), cluster_gs=TRUE,cluster_gene = TRUE,h=0.95) In the figure below, the top 30 enriched terms can be clustered into 6 groups (cluster size can be adjusted by h). Genes belong to each term is marked with red in the table cell. As we can see, the top enriched gene sets are related with lipid biosynthetic process. Detail about this process, please check ‘GO_LIPID_BIOSYNTHETIC_PROCESS’ To explore the handlers in draw.funcEnrich.cluster(), please try the following scripts. draw.funcEnrich.cluster(funcEnrich_res= res_up,top_number=30,gs_cex = 0.8,gene_cex=0.9,pv_cex=0.8,pdf_file = sprintf(&#39;%s/funcEnrich_clusterGS.pdf&#39;,analysis.par$out.dir.PLOT), cluster_gs=TRUE,cluster_gene = FALSE) draw.funcEnrich.cluster(funcEnrich_res= res_up,top_number=30,gs_cex = 0.8,gene_cex=0.9,pv_cex=0.8,pdf_file = sprintf(&#39;%s/funcEnrich_clusterGENE.pdf&#39;,analysis.par$out.dir.PLOT), cluster_gs=FALSE,cluster_gene = TRUE) draw.funcEnrich.cluster(funcEnrich_res= res_up,top_number=30,gs_cex = 1.5,gene_cex=1.4,pv_cex=1.2,pdf_file = sprintf(&#39;%s/funcEnrich_clusterNO.pdf&#39;,analysis.par$out.dir.PLOT), cluster_gs=FALSE,cluster_gene = FALSE) QI.5: What are the biological functions of the target genes of these top DA drivers ? The biological function of driver is to regulated by its target genes. For a driver, what are the biological functions of its target genes? NetBID2 provides a function draw.bubblePlot() to investigate this question. First, get the ID conversion table. This is because NetBID2 only accepts gene symbol as ID type for gene set annotation (for more general application, please check the last part of this section). This conversion table is already wrapped inside analysis.par super list created by get_IDtransfer2symbol2type(). If not, user could use get_IDtransfer2symbol2type() to get. # Get ID conversion table transfer_tab &lt;- analysis.par$transfer_tab draw.bubblePlot() has 21 parameters, but most of them are the same as in funcEnrich.Fisher(). For the demo, user only need to prepare the ID conversion table to transfer2symbol2type. Another interested parameter is display_gs_list, which can be set to pick which gene set(s) to be displayed in the plot. # Bubble Plot to show target genes enriched biological functions draw.bubblePlot(driver_list= driver_list,show_label=ms_tab[driver_list,&#39;gene_label&#39;], Z_val=ms_tab[driver_list,sprintf(&#39;Z.%s_DA&#39;,comp_name)], driver_type=ms_tab[driver_list,&#39;gene_biotype&#39;], target_list=analysis.par$merge.network$target_list,transfer2symbol2type=transfer_tab, bg_list=ms_tab[,&#39;geneSymbol&#39;],min_gs_size=5,max_gs_size=500,use_gs=c(&#39;H&#39;), top_geneset_number=30,top_driver_number=10, pdf_file = sprintf(&#39;%s/bubblePlot.pdf&#39;,analysis.par$out.dir.PLOT), main=&#39;Bubbleplot for top driver targets&#39;) Explanation of the bubble plot. Each column is a driver, each row is a curated gene set. The size of the circle is the number of intersected genes (legend on the top) and the color shade of the circle represents the significance using P-value (legend on the right). The color shade of boxes above the barplot shows the significance of the each driver (user need to input the Z-statistics). The barplot at the bottom shows the target size of each driver (filtered by protein coding), and the circle below the barplot represents the driver type (optional, driver_type). For example, the target genes of the Group4 up driver PDE7B_SIG are significantly enriched in KEGG_AXON_GUIDANCE term (with P-value of 1e-10), with 17 intersected genes. To explore the handlers in draw.bubblePlot(), please try the following scripts. draw.bubblePlot(driver_list= driver_list,show_label=ms_tab[driver_list,&#39;gene_label&#39;], Z_val=ms_tab[driver_list,sprintf(&#39;Z.%s_DA&#39;,comp_name)], driver_type=ms_tab[driver_list,&#39;gene_biotype&#39;], target_list=analysis.par$merge.network$target_list,transfer2symbol2type=transfer_tab, bg_list=ms_tab[,&#39;geneSymbol&#39;],min_gs_size=10,max_gs_size=300,use_gs=c(&#39;CP:KEGG&#39;), top_geneset_number=30,top_driver_number=30, pdf_file = sprintf(&#39;%s/bubblePlot_KEGG.pdf&#39;,analysis.par$out.dir.PLOT), main=&#39;Bubbleplot for top driver targets&#39;) # Add marker genes mark_gene &lt;- c(&#39;KCNA1&#39;,&#39;EOMES&#39;,&#39;KHDRBS2&#39;,&#39;RBM24&#39;,&#39;UNC5D&#39;) ## marker for Group4 draw.bubblePlot(driver_list= driver_list,show_label=ms_tab[rownames(sig_driver),&#39;gene_label&#39;], Z_val=ms_tab[driver_list,sprintf(&#39;Z.%s_DA&#39;,comp_name)], driver_type=ms_tab[driver_list,&#39;gene_biotype&#39;], target_list=analysis.par$merge.network$target_list,transfer2symbol2type=transfer_tab, bg_list=ms_tab[,&#39;geneSymbol&#39;],min_gs_size=10,max_gs_size=300,use_gs=c(&#39;CP:KEGG&#39;,&#39;CP:BIOCARTA&#39;,&#39;H&#39;), top_geneset_number=30,top_driver_number=80, pdf_file = sprintf(&#39;%s/bubblePlot_combine.pdf&#39;,analysis.par$out.dir.PLOT), main=&#39;Bubbleplot for top driver targets&#39;, mark_gene=ms_tab[which(ms_tab$geneSymbol %in% mark_gene),&#39;originalID_label&#39;],gs_cex = 1,driver_cex=1.2) Part II: More details about the selected driver QII.1: How to interpret the significance of the selected driver ? To study a single driver or some specific drivers, NetBID2 provides function draw.GSEA() to draw the classic GSEA plot, in order to faciliate the interpretation of the significance of target driver(s). First, retrieve the differential expressed gene profile first. # Get the DE file DE &lt;- analysis.par$DE[[comp_name]] DE_profile &lt;- DE$`Z-statistics`; names(DE_profile) &lt;- rownames(DE) Then, extract out the target gene list and the regulation direction of the selected driver. Here, we use the P-value in master table as annotation for the enrichment. The classic GSEA plot test may use different statistics, user can decide which one to use as annotation and calculate it. # Use the first driver in the driver list as an example use_driver &lt;- driver_list[1] use_target_genes &lt;- analysis.par$merge.network$target_list[[use_driver]]$target use_target_direction &lt;- sign(analysis.par$merge.network$target_list[[use_driver]]$spearman) ## 1/-1 annot &lt;- sprintf(&#39;P-value: %s&#39;,signif(ms_tab[use_driver,sprintf(&#39;P.Value.%s_DA&#39;,comp_name)],2)) # Draw classic GSEA plot for one driver draw.GSEA(rank_profile=DE_profile,use_genes=use_target_genes,use_direction=use_target_direction, main=sprintf(&#39;GSEA plot for driver %s&#39;,ms_tab[use_driver,&#39;gene_label&#39;]), pdf_file = sprintf(&#39;%s/GSEA_each_direction.pdf&#39;,analysis.par$out.dir.PLOT), annotation=annot,annotation_cex=1.2, left_annotation=&#39;high in G4&#39;,right_annotation=&#39;high in others&#39;) NetBID2 will draw a classic GSEA plot, if no direction information is provided. # GSEA plot without direction, without annotation draw.GSEA(rank_profile=DE_profile,use_genes=use_target_genes,use_direction=NULL, main=sprintf(&#39;GSEA plot for driver %s&#39;,ms_tab[use_driver,&#39;gene_label&#39;]), pdf_file = sprintf(&#39;%s/GSEA_each.pdf&#39;,analysis.par$out.dir.PLOT), annotation=&#39;&#39;,annotation_cex=1.2, left_annotation=&#39;high in G4&#39;,right_annotation=&#39;high in others&#39;) QII.2: How to visualize the network structure of the selected driver ? The sub-network structure of the selected driver composed of one source node (driver) and its target nodes (target genes). The edges of the network contains weight of mutual information and direction of the sign ofspearman. # Use the first driver in the driver list as an example use_driver &lt;- driver_list[1] # Define edges of the network edge_score &lt;- analysis.par$merge.network$target_list[[use_driver]]$MI*sign(analysis.par$merge.network$target_list[[use_driver]]$spearman) names(edge_score) &lt;- analysis.par$merge.network$target_list[[use_driver]]$target For better visualization, users can adjust n_layer and label_cex parameters. n_layer controls number of circle layers to display. label_cex controls the text size of the gene names. By default, the alphabetical_order=FALSE and the edges are sorted by the edge score. If alphabetical_order=TRUE, the target genes are sorted alphabetically from inner layer to outer layer. # Draw sub-network structure of selected driver draw.targetNet(source_label=ms_tab[use_driver,&#39;gene_label&#39;],source_z=ms_tab[use_driver,sprintf(&#39;Z.%s_DA&#39;,comp_name)], edge_score = edge_score,pdf_file=sprintf(&#39;%s/targetNet_out.pdf&#39;,analysis.par$out.dir.PLOT),label_cex = 0.4,n_layer=4, alphabetical_order=TRUE) Users can also change the arrow direction to “in” (from target to source), and set alphabetical_order=FALSE, so the target genes are sorted by the edge score (positive to negative) from inner layer to outer layer. As shown below. draw.targetNet(source_label=ms_tab[use_driver,&#39;gene_label&#39;],source_z=ms_tab[use_driver,sprintf(&#39;Z.%s_DA&#39;,comp_name)], edge_score = edge_score,pdf_file=sprintf(&#39;%s/targetNet_in.pdf&#39;,analysis.par$out.dir.PLOT),label_cex = 0.35,arrow_direction = &#39;in&#39;,n_layer=6) To draw the sub-network structure of two selected drivers, users can call draw.targetNet.TWO(). Parameters like n_layer and alphabetical_order are the same as in draw.targetNet(). The overlapped target genes between these two drivers will be displayed in the middle as shown below. # Draw sub-network structure for two selected drivers # Use the first two drivers in the driver list as an example use_driver2 &lt;- driver_list[2] edge_score2 &lt;- analysis.par$merge.network$target_list[[use_driver2]]$MI*sign(analysis.par$merge.network$target_list[[use_driver2]]$spearman) names(edge_score2) &lt;- analysis.par$merge.network$target_list[[use_driver2]]$target use_genes &lt;- unique(analysis.par$merge.network$network_dat$target.symbol) draw.targetNet.TWO(source1_label=ms_tab[use_driver,&#39;gene_label&#39;],edge_score1 = edge_score, source2_label=ms_tab[use_driver2,&#39;gene_label&#39;],edge_score2 = edge_score2, source1_z=ms_tab[use_driver,sprintf(&#39;Z.%s_DA&#39;,comp_name)],source2_z=ms_tab[use_driver,sprintf(&#39;Z.%s_DA&#39;,comp_name), pdf_file=sprintf(&#39;%s/targetNetTWO.pdf&#39;,analysis.par$out.dir.PLOT),total_possible_target=use_genes,show_test=TRUE,label_cex = 0.2) To check the overlapped target genes of these two drivers, users can call test.targetNet.overlap(). # To show the overlapped target genes from two selected drivers test.targetNet.overlap(source1_label=ms_tab[use_driver,&#39;gene_label&#39;],source2_label=ms_tab[use_driver2,&#39;gene_label&#39;], target1 = names(edge_score),target2 = names(edge_score2),total_possible_target=use_genes) QII.3: What is the expression/activity of this selected driver across subtypes of sample? draw.categoryValue() draws a scatter box plot to visualize one selected driver’s expression value and activity value across different phenotype subgroups of samples. Two side-by-side scatter box plots will be created. The left plot shows driver’s activity values in different phenotype subgroups, each point is a sample. The right plot shows driver’s expression value in different phenotype sub- groups, each point is a sample. To convert sample names to subgroups, one can call get_obs_label(). To modify the order of subgroups, one can set class_order. As shown in the figure below. # Creates a vector of each sample’s selected phenotype descriptive information use_obs_class &lt;- get_obs_label(phe_info = phe_info,&#39;subgroup&#39;) draw.categoryValue(ac_val=ac_mat[use_driver,],exp_val=exp_mat[ms_tab[use_driver,&#39;originalID&#39;],],use_obs_class=use_obs_class, class_order=c(&#39;WNT&#39;,&#39;SHH&#39;,&#39;G4&#39;),class_srt=30,main_ac = ms_tab[use_driver,&#39;gene_label&#39;],main_exp=ms_tab[use_driver,&#39;geneSymbol&#39;], pdf_file=sprintf(&#39;%s/categoryValue_demo1.pdf&#39;,analysis.par$out.dir.PLOT), pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) To explore the handlers in draw.categoryValue(), please try the following scripts. draw.categoryValue(ac_val=ac_mat[use_driver,],exp_val=NULL,use_obs_class=use_obs_class,class_order=c(&#39;WNT&#39;,&#39;SHH&#39;,&#39;G4&#39;), pdf_file=sprintf(&#39;%s/categoryValue_demo2.pdf&#39;,analysis.par$out.dir.PLOT), pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) use_obs_class &lt;- get_obs_label(phe_info = phe_info,c(&#39;subgroup&#39;,&#39;gender&#39;)) draw.categoryValue(ac_val=ac_mat[use_driver,],exp_val=exp_mat[ms_tab[use_driver,&#39;originalID&#39;],],use_obs_class=use_obs_class, class_srt=30,main_ac = ms_tab[use_driver,&#39;gene_label&#39;],main_exp=ms_tab[use_driver,&#39;geneSymbol&#39;], pdf_file=sprintf(&#39;%s/categoryValue_demo3.pdf&#39;,analysis.par$out.dir.PLOT), pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) QII.4: What are the functions of the target genes of this selected driver ? Similar to the study of drivers, we can also study the functional enrichment for its target genes. First, please check the gene ID. If the original ID is not gene symbol, users can call get_name_transfertab() to convert ID. # Use the first driver in the driver list as an example use_driver &lt;- driver_list[1] use_target_genes &lt;- analysis.par$merge.network$target_list[[use_driver]]$target #use_target_genes &lt;- get_name_transfertab(use_genes= use_target_genes,transfer_tab=transfer_tab,ignore_version=TRUE) # optional # Converts the original gene IDs into target gene IDs, with conversion table provided bg_list &lt;- get_name_transfertab(use_genes= unique(analysis.par$merge.network$network_dat$target),transfer_tab=transfer_tab,ignore_version=TRUE) res &lt;- funcEnrich.Fisher(input_list= use_target_genes,bg_list= bg_list,use_gs=c(&#39;H&#39;,&#39;CP:REACTOME&#39;,&#39;BP&#39;,&#39;CGP&#39;,&#39;CP:KEGG&#39;), Pv_thre=0.1,Pv_adj = &#39;none&#39;,min_gs_size = 30, max_gs_size = 500) draw.funcEnrich.cluster(funcEnrich_res= res,top_number=20,gs_cex = 1.2,gene_cex=1,pv_cex=1,Pv_thre=0.1, pdf_file = sprintf(&#39;%s/funcEnrich_clusterBOTH_%s.pdf&#39;,analysis.par$out.dir.PLOT,use_driver), cluster_gs=TRUE,cluster_gene = TRUE,h=0.95) Part III: Other analyses NetBID2 can do QIII.1: What are the activities of the curated gene sets across all samples? The target genes of a driver can be seen as a special “gene set”. We can use the same procedure to study the curated gene sets from the public datasets. Similar to the target-gene-study, we can calculate their activities and P-values. First, prepare the expression matrix. The row names must be gene symbols. # Preload database files into R workspace db.preload(use_level=&#39;gene&#39;,use_spe=&#39;human&#39;,update=FALSE) # Get the expression matrix, row names must be gene symbols exp_mat &lt;- exprs(analysis.par$cal.eset) # If original is gene-based expression matrix, just use the exp_mat exp_mat_gene &lt;- exp_mat Second, choose gene sets. If users want to combine the categories, please use merge_gs(). Then, use cal.Activity.GS() to calculate the activity values for the gene sets across all samples. # Calculate activity for all gene sets use_gs2gene &lt;- merge_gs(all_gs2gene=all_gs2gene,use_gs=c(&#39;H&#39;,&#39;CP:BIOCARTA&#39;,&#39;CP:REACTOME&#39;,&#39;CP:KEGG&#39;,&#39;C5&#39;)) ac_gs &lt;- cal.Activity.GS(use_gs2gene = use_gs2gene,cal_mat = exp_mat_gene) Third, perform statistical testing for the activity value of the gene sets. Please call getDE.BID.2G() or getDE.limma.2G(). # Calculate DA phe_info &lt;- pData(analysis.par$cal.eset) G0 &lt;- rownames(phe_info)[which(phe_info$`subgroup`!=&#39;G4&#39;)] # get sample list for G0 G1 &lt;- rownames(phe_info)[which(phe_info$`subgroup`==&#39;G4&#39;)] # get sample list for G1 DA_gs_bid &lt;- getDE.BID.2G(eset=generate.eset(ac_gs),G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;others&#39;) Draw a volcano plot to visualize the results. draw.volcanoPlot() will also return the significant gene sets to sig_gs. # Draw vocalno plot for top significant gene sets sig_gs &lt;- draw.volcanoPlot(dat= DA_gs_bid,label_col=&#39;ID&#39;,logFC_col=&#39;logFC&#39;, Pv_col=&#39;P.Value&#39;,logFC_thre=0.2,Pv_thre=1e-3, main=&#39;Volcano Plot for gene sets&#39;,show_label=TRUE,label_type = &#39;distribute&#39;,label_cex = 0.5, pdf_file=sprintf(&#39;%s/vocalno_GS_DA.pdf&#39;,analysis.par$out.dir.PLOT)) Draw a heatmap for the top significant gene sets. # Draw heatmap for top significant gene sets draw.heatmap(mat=ac_gs[sig_gs$ID,],pdf_file=sprintf(&#39;%s/heatmap_GS.pdf&#39;,analysis.par$out.dir.PLOT),scale=&#39;row&#39;, phenotype_info=phe_info,use_phe=c(&#39;gender&#39;,&#39;subgroup&#39;)) NetBID2 style GSEA plot of gene sets can be plotted by draw.GSEA.NetBID.GS(). Different from draw.GSEA.NetBID(), the genes in the gene sets will not be divided into positively-regulated/negatively-regulated groups. # Draw GSEA plot for top significant gene sets DE &lt;- analysis.par$DE[[comp_name]] draw.GSEA.NetBID.GS(DE=DE,name_col=&#39;ID&#39;,profile_col=&#39;t&#39;,profile_trend=&#39;pos2neg&#39;, sig_gs_list = sig_gs$ID, gs_DA_Z= DA_gs_bid[sig_gs$ID,&#39;Z-statistics&#39;], use_gs2gene = use_gs2gene, top_gs_number=20,target_col=&#39;RdBu&#39;, left_annotation = &#39;high in others&#39;,right_annotation = &#39;high in G4&#39;, main= comp_name,Z_sig_thre=1.64,profile_sig_thre = 0, pdf_file=sprintf(&#39;%s/NetBID_GSEA_GS_demo1.pdf&#39;,analysis.par$out.dir.PLOT)) The target_col has two options, RdBu and black. The figure below is showing when target_col = &#39;black&#39;. draw.GSEA.NetBID.GS(DE=DE,name_col=&#39;ID&#39;,profile_col=&#39;t&#39;,profile_trend=&#39;pos2neg&#39;, sig_gs_list = sig_gs$ID, gs_DA_Z= DA_gs_bid[sig_gs$ID,&#39;Z-statistics&#39;], use_gs2gene = use_gs2gene, top_gs_number=20,target_col=&#39;black&#39;, left_annotation = &#39;high in others&#39;,right_annotation = &#39;high in G4&#39;, main= comp_name,Z_sig_thre=1.64,profile_sig_thre = 0, pdf_file=sprintf(&#39;%s/NetBID_GSEA_GS_demo2.pdf&#39;,analysis.par$out.dir.PLOT)) For a specific gene set, draw.GSEA() can be used to display the significance of genes from the DE profile. # Draw GSEA plot for one gene set DE_profile &lt;- DE$`Z-statistics`; names(DE_profile) &lt;- rownames(DE) use_target_genes &lt;- rownames(DE)[which(DE$ID %in% use_gs2gene[[sig_gs$ID[1]]])] use_gs &lt;- sig_gs$ID[1] draw.GSEA(rank_profile=DE_profile,use_genes=use_target_genes, main=sprintf(&#39;GSEA plot for %s&#39;,use_gs), pdf_file = sprintf(&#39;%s/GSEA_GS_each.pdf&#39;,analysis.par$out.dir.PLOT), left_annotation=&#39;high in G4&#39;,right_annotation=&#39;high in others&#39;, annotation=sprintf(&#39;P-value: %s&#39;,signif(sig_gs[use_gs,&#39;P.Value&#39;],2))) For a specific gene set, draw.categoryValue() can be used to display the activity pattern across all samples. # Draw category plot for one gene set use_obs_class &lt;- get_obs_label(phe_info = phe_info,&#39;subgroup&#39;) draw.categoryValue(ac_val=ac_gs[use_gs,],use_obs_class=use_obs_class, class_order=c(&#39;WNT&#39;,&#39;SHH&#39;,&#39;G4&#39;),class_srt=30,pdf_file=sprintf(&#39;%s/categoryValue_GS_demo1.pdf&#39;,analysis.par$out.dir.PLOT), main_ac= use_gs,main_cex=0.8, pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) QIII.2: How to find drivers share significantly overlapped target genes ? To check the target gene overlapping among drivers, users can use draw.bubblePlot() in a different way. Just change the input into ome gene list (from gene set) and a fake conversion table. gs2gene_target &lt;- analysis.par$merge.network$target_list[driver_list] gs2gene_target &lt;- lapply(gs2gene_target,function(x)x$target) transfer_tab_fake &lt;- data.frame(from=transfer_tab[,1],to=transfer_tab[,1],gene_biotype=transfer_tab[,3],stringsAsFactors=F) draw.bubblePlot(driver_list= driver_list,show_label=ms_tab[driver_list,&#39;gene_label&#39;], Z_val=ms_tab[driver_list,sprintf(&#39;Z.%s_DA&#39;,comp_name)], driver_type=ms_tab[driver_list,&#39;gene_biotype&#39;], target_list=analysis.par$merge.network$target_list,transfer2symbol2type=transfer_tab_fake, bg_list=ms_tab[,&#39;geneSymbol&#39;],gs2gene=gs2gene_target, min_gs_size=10,max_gs_size=1000, use_gs=&#39;all&#39;, top_geneset_number=10,top_driver_number=10, pdf_file = sprintf(&#39;%s/bubblePlot_overlap.pdf&#39;,analysis.par$out.dir.PLOT), main=&#39;Bubbleplot for top driver targets&#39;) How to modify the figure size created by draw. functions ? NetBID2 has 14 functions start with draw.. These functions all have one option pdf_file=. If it is set with a file path, the function will automatically save the plot as a PDF file without adjusting the figure size. If it is set to NULL, the figure will show in a new window without saving to PDF. But user can add pdf() before the draw. function, and add dev.off() after the draw. function to save it manually. In this way, one can customize the figure size. For details, please check ?pdf. cex option in all the draw. functions are used to adjust the text size, and the PDF figure size will be adjusted based on that.",
    "url": "http://localhost:4000/docs/advanced_analysis",
    "relUrl": "/docs/advanced_analysis"
  },
  "3": {
    "id": "3",
    "title": "- Driver estimation",
    "content": "Driver Estimation The purpose of this part: retrieve potential drivers for interested phenotype and generate a master table for drivers. One “lazy mode” function without flexiable options is available for this part of analysis: NetBID.lazyMode.DriverEstimation(). User could check the manual for this function and try the demo code for usage. The complete step-by-step demo script for network construction can be found here, pipeline_analysis_demo1.R. Quick Navigation for this page Step 0: Preparations Step 1: Load in the expression dataset for analysis (exp-load, exp-cluster, exp-QC) Q&amp;A: What to do if the ID types from network-construction dataset and analysis dataset are different? Step 2: Read in network files and calcualte driver activity (act-get) Q&amp;A: Why study driver’s activity ? Step 3: Get differential expression (DE) / differential activity (DA) for drivers (act-DA) Step 4: Generate a master table for drivers (ms-tab) Q&amp;A: How to interpret and use the master table ? Step 0: Preparations Purpose: create an organized working directory for the driver estimation step in NetBID2 analysis. Make sure you have NetBID2 package. library(NetBID2) First, retrieve a constructed network for driver analysis. If user followed the Network construction tutorial, the path of the network project network.dir should have been set. For details, please check Network construction: Step 0. The network.project.name is used to distinguish different network construction jobs when using SJAracne.prepare(), under the main path of network.dir. By specifying network.dir and network.project.name, user should be able to retrieve the target network constructed by network construction part in NetBID2 and SJARACNe. For the online tutorial, we have already prepared the demo dataset’s network constructed by SJARACNe. So users don’t need to run SJARACNe for the demo, and can direclty proceed to the following pipeline. network.dir &lt;- sprintf(&#39;%s/demo1/network/&#39;,system.file(package = &quot;NetBID2&quot;)) # use demo network in the package network.project.name &lt;- &#39;project_2019-02-14&#39; Next, create directories and folders to save and organize your analysis results. We have designed a function NetBID.analysis.dir.create() to handle the working directories, so users can have a better data organization. Similar to the one in network construction. This function needs users to define the main working directory project_main_dir and the project’s name project_name. To prevent previous project with the same project_main_dir and project_name from being rewrite, it is highly suggested to add a time tag to your project_name. # Define main working directory and project name project_main_dir &lt;- &#39;test/&#39; # user defined main directory for the project, one main directory could current_date &lt;- format(Sys.time(), &quot;%Y-%m-%d&quot;) # optional, if user like to add current date to name the project folder project_name &lt;- sprintf(&#39;driver_%s&#39;,current_date) # project name for the project folders under main directory NetBID.analysis.dir.create() creates a main working directory with a subdirectory of the project. It also automatically creates three subfolders (QC, DATA and PLOT) within the project folder. QC/, storing Quality Control related plots; DATA/, saving data in RData format; PLOT/, storing output plots. It also returns a list object, here named analysis.par with directory information wrapped inside. This list is an ESSENTIAL variable for driver estimation step, all the important intermediate data generated later will be wrapped inside. # Create a hierarchcial working directory and return a list contains the hierarchcial working directory information # This list object (analysis.par) is an ESSENTIAL variable in driver estimation pipeline analysis.par &lt;- NetBID.analysis.dir.create(project_main_dir=project_main_dir, project_name=project_name, network_dir=network.dir, network_project_name=network.project.name) Step 1: Load in the expression dataset for analysis (exp-load, exp-cluster, exp-QC) Purpose: load in the expression dataset for driver estimation analysis step. For driver estimation, we will need an expression dataset containing the interested phenotype with proper control samples. Compared with the dataset used for network construction, there is no strong requirement for large sample size. User could choose to use the same dataset in network construction for this part but not necessary. For demo, we choose to use the same dataset here. If user choose to use the same dataset, no pre-processing of the dataset is required, since we saved the expression dataset after quality control as RData from network construction part in NetBID2, we can load it back directly. Users need to assign network.par$net.eset to analysis.par$cal.eset, cause for driver estimation step, the ESSENTIAL variable is analysis.par. # If use the same expression dataset as in the network construction, just reload it directly load(sprintf(&#39;%s/DATA/network.par.Step.exp-QC.RData&#39;,network.dir)) # RData saved after QC in the network construction step analysis.par$cal.eset &lt;- network.par$net.eset If user choose to use a different dataset, please complete the first three steps in Network construction first to process the dataset before further analysis. For persistent storage of data, and prevent the re-run of all previous steps. Users can checkout and save analysis.par as RData for this part. The function NetBID.saveRData() provide easier pipeline step checkout and reference. Giving pipeline step name to step, the analysis.par will be saved with step name as analysis.par$out.dir.DATA/analysis.par.Step.{exp-QC}.RData. # Save Step 1 network.par as RData NetBID.saveRData(analysis.par=analysis.par,step=&#39;exp-QC&#39;) What to do if the ID types from network-construction dataset and analysis dataset are different? It is highly suggested to use the ID type from network-construction dataset as the main ID type. The purpose of NetBID2 is to find potential drivers in a biological process of interest based on the data-driven gene regulatory network. Each drivers’ activity is evaluated based on the network structure (its directly targeted genes). If a driver doesn’t exist in the pre-generated network, it will not be used in activity calculation. On the contrary, if a driver doesn’t exist in the analysis dataset, it can still have its activity been calculated (if its target genes’ expression values are available). We strongly recommend to align the ID type from the analysis dataset to the network-construction dataset using update_eset.feature(). The ID conversion table can be obtained from GPL files or get_IDtransfer() and get_IDtransfer_betweenSpecies(). The most complicated situation is, the levels of network-construction ID type and the analysis expression dataset are different (e.g. transcript level vs. gene level). NetBID2 provides update_eset.feature() to solve this problem, by assigning distribute_method and merge_method parameters. Step 2: Read in network files and calcualte driver activity (act-get) Please skip the following line if you didn’t close R session after completed Step 1. Don’t skip, if you have checked out and closed R session after completed the Step 1. Before start Step 2, please reload analysis.par RData from Step 1. NetBID.loadRData() reloads RData saved by NetBID.saveRData(). It prevents user from repeating former pipeline steps. If the re-opened R session doesn’t have analysis.par in the environment, please comment off the first two command lines. It will create a temporary analysis.par with path of the saved Step 1 RData, analysis.par$out.dir.DATA. The path test//driver_2019-05-06//DATA/ here is just an example, users need to give their own path used to save analysis.par RData from Step 1. # Reload network.par RData from Step 1 #analysis.par &lt;- list() #analysis.par$out.dir.DATA &lt;- &#39;test//driver_2019-05-06//DATA/&#39; NetBID.loadRData(analysis.par=analysis.par,step=&#39;exp-QC&#39;) Firstly, get the network constructed by SJAracne. If one followed the pipeline, the file path should be analysis.par$tf.network.file and analysis.par$sig.network.file. Use get.SJAracne.network() to read in the network information. If one didn’t follow the pipeline, just pass the directory of network to get.SJAracne.network(). analysis.par$tf.network &lt;- get.SJAracne.network(network_file=analysis.par$tf.network.file) analysis.par$sig.network &lt;- get.SJAracne.network(network_file=analysis.par$sig.network.file) More about get.SJAracne.network() and related function. It reads SJARACNe network construction result and returns a list object contains three elements, network_data, target_list and igraph_obj. network_dat is a data.frame, contains all the information of the network SJARACNe constructed. target_list is a driver-to-target list object. Please check details in get_net2target_list(). igraph_obj is an igraph object used to save this directed and weighted network. Each edge of the network has two attributes, weight and sign. Weight is the “MI (mutual information)” value and sign is the sign of the spearman correlation coefficient (1, positive regulation; -1, negative regulation). To updata the network dataset, user can call update_SJAracne.network(). It updates the network object created by get.SJAracne.network, using constraints like statistical thresholds and interested gene list. Generate an HTML QC report for the constructed network, using igraph_obj. draw.network.QC(analysis.par$tf.network$igraph_obj,outdir=analysis.par$out.dir.QC,prefix=&#39;TF_net_&#39;,html_info_limit=FALSE) draw.network.QC(analysis.par$sig.network$igraph_obj,outdir=analysis.par$out.dir.QC,prefix=&#39;SIG_net_&#39;,html_info_limit=TRUE) Two QC reports have been created. One for the transcription factor TF network, the other one is for signaling factor SIG network. - What information can you get from the HTML QC report of network? A table for network. It shows some basic statistics to characterize the target network, including size and centrality etc. A table for drivers. It shows detailed statistics for all drivers in the network. A density over histogram to show the distribution of the degree of nodes and the target size of all drivers. The average target size around several hundreds may be good by experience. A scatter plot to check if the network is scale-free. It is good but not necessary for a gene regulatory network to have the scale-free topology feature. Second, merge TF-network and SIG-network. There are two ways to merge the networks. (1) Merge the networks first using merge_TF_SIF.network(), then calculate driver’s activity value. (2) Calculate the driver’s activity value in both TF-network and SIG-network, then merge them together using merge_TF_SIG.AC(). Both ways give the same result. Drivers in the analysis.par$merge.network will have suffix of ‘_TF’ and ‘_SIG’ to distinguish the type of the driver. It is possible to see a driver with both ‘_TF’ and ‘_SIG’. # Merge network first analysis.par$merge.network &lt;- merge_TF_SIG.network(TF_network=analysis.par$tf.network,SIG_network=analysis.par$sig.network) Third, get the activity matrix for all possible drivers using cal.Activity(). Driver’s activity value quantifies its influence in a biological process. It is evaluated from the driver’s accumulative effects to its targets. The evaluation strategies are “mean””, “weighted mean”, “maxmean” and “absmean”. “Weighted mean” is the MI (mutual information) value with the sign of the spearman correlation. For example, if users choose “weighted mean” to calcualte the activity of driver. The higher expression value of its positively-regulated genes and the lower expression value of its negatively-regulated genes, the higher activity value of that driver will be. If user would like to perform Z-transformation to the expression matrix before calculating the activity values, he can set std=TRUE. # Get activity matrix ac_mat &lt;- cal.Activity(target_list=analysis.par$merge.network$target_list,cal_mat=exprs(analysis.par$cal.eset),es.method=&#39;weightedmean&#39;) Now, we have an activity matrix ac_mat for drivers. Rows are drivers, columns are samples. Due to the similar way of data display, and same phenotype information sharing, we can wrap the activity matrix into the ExpressionSet class object, just like expression matrix. # Create eset using activity matrix analysis.par$merge.ac.eset &lt;- generate.eset(exp_mat=ac_mat,phenotype_info=pData(analysis.par$cal.eset)[colnames(ac_mat),], feature_info=NULL,annotation_info=&#39;activity in net-dataset&#39;) Fourth, create QC report for the activity matrix. Use draw.eset.QC() to create the HTML QC report QC for AC of analysis.par$merge.ac.eset. # QC plot for activity eset draw.eset.QC(analysis.par$merge.ac.eset,outdir=analysis.par$out.dir.QC,intgroup=NULL,do.logtransform=FALSE,prefix=&#39;AC_&#39;, pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;),pca_plot_type=&#39;2D.interactive&#39;) Last, save analysis.par. For persistent storage of data, and prevent the re-run of all previous steps. Users can checkout now and save analysis.par as RData for this part. # Save Step 2 analysis.par as RData NetBID.saveRData(analysis.par=analysis.par,step=&#39;act-get&#39;) Why study driver’s activity ? Drivers, such as transcription factors (TF) bind to the enhancer or promoter regions of the target genes and regulate their expression level. Once the TF has been synthesized, there are still many steps between mRNA translation of a TF and the actual transcriptional regulation of target genes. The activity is controlled by most of the following processes, nuclear localization (import into the cell nucleaus), activation through signal-sensing domain (e.g. ligand binding or post-translational modifications: methylation, ubiquitination and phosphorylation, which is essential for dimerization and promoter binding), access to the DNA-binding site (epigenetic features of the genome), and interaction with other cofactors or TFs (form a complex). Thus, sometimes the expression trend and the activity pattern of a driver may be contradicted. Due to these “hidden effects, the analysis of the activity of a driver maybe more fruitful than the analysis its expression level. Step 3: Get differential expression (DE) / differential activity (DA) for drivers (act-DA) Purpose: get significantly differential expression (DE) and activity (DA) for all possible drivers between two phenotype groups. Please skip the following line if you didn’t close R session after completed Step 1 and Step 2. Don’t skip, if you have checked out and closed R session after completed the Step 1 and Step 2. Before start Step 3, please reload analysis.par RData from Step 2. NetBID.loadRData() reloads RData saved by NetBID.saveRData(). It prevents user from repeating former pipeline steps. If the re-opened R session doesn’t have analysis.par in the environment, please comment off the first two command lines. It will create a temporary analysis.par with path of the saved Step 2 RData, analysis.par$out.dir.DATA. The path test//driver_2019-05-06//DATA/ here is just an example, users need to give their own path used to save analysis.par RData from Step 2. # Reload network.par RData from Step 2 #analysis.par &lt;- list() #analysis.par$out.dir.DATA &lt;- &#39;test//driver_2019-05-06//DATA/&#39; NetBID.loadRData(analysis.par=analysis.par,step=&#39;act-get&#39;) To compare the drivers’ activity between two phenotype groups. In the demo dataset, one column of the phenotype data frame is “subgroup”. It contains 3 phenotype groups, WNT, SHH and G4. To compare the driver’s DE/DA between any two groups (G1 vs. G0 in the following functions), NetBID2 provides two major functions getDE.BID.2G() and getDE.limma.2G(). Users need to assign sample names from each group to G1_name and G0_name. In the script below, we compared between G4.Vs.WNT and G4.Vs.SHH. Each comparison has a name (highly suggested, will be displayed in the final master table), and the results are saved in analysis.par$DE and analysis.par$DA. More detail. getDE.BID.2G() uses Bayesian Inference method to calculate DE and DA values, by setting method=&#39;Bayesian&#39;. If set method=&#39;MLE&#39;, it will take shorter time to calculate. If the input is RNA-Seq dataset, user can use DE output from DESeq2. Just pay attention to the column names, one column should be Z-statistics. If the phenotype is ordinal or more complicated, user can use bid() or limma() to analyze. # Create empty list to store comparison result analysis.par$DE &lt;- list() analysis.par$DA &lt;- list() # First comparison: G4 vs. WNT comp_name &lt;- &#39;G4.Vs.WNT&#39; # Each comparison must has a name # Get sample names from each compared group phe_info &lt;- pData(analysis.par$cal.eset) G1 &lt;- rownames(phe_info)[which(phe_info$`subgroup`==&#39;G4&#39;)] # Experiment group G0 &lt;- rownames(phe_info)[which(phe_info$`subgroup`==&#39;WNT&#39;)] # Control group DE_gene_bid &lt;- getDE.BID.2G(eset=analysis.par$cal.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;WNT&#39;) DA_driver_bid &lt;- getDE.BID.2G(eset=analysis.par$merge.ac.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;WNT&#39;) # Save comparison result to list element in analysis.par, with comparison name analysis.par$DE[[comp_name]] &lt;- DE_gene_bid analysis.par$DA[[comp_name]] &lt;- DA_driver_bid # Second comparison: G4 vs. SHH comp_name &lt;- &#39;G4.Vs.SHH&#39; # Each comparison must has a name # Get sample names from each compared group phe_info &lt;- pData(analysis.par$cal.eset) G1 &lt;- rownames(phe_info)[which(phe_info$`subgroup`==&#39;G4&#39;)] # Experiment group G0 &lt;- rownames(phe_info)[which(phe_info$`subgroup`==&#39;SHH&#39;)] # Control group DE_gene_bid &lt;- getDE.BID.2G(eset=analysis.par$cal.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;SHH&#39;) DA_driver_bid &lt;- getDE.BID.2G(eset=analysis.par$merge.ac.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;SHH&#39;) # Save comparison result to list element in analysis.par, with comparison name analysis.par$DE[[comp_name]] &lt;- DE_gene_bid analysis.par$DA[[comp_name]] &lt;- DA_driver_bid To combine multiple comparison results. Wrap all the comparison results into the DE_list, and pass it to combineDE(). It returns a list contains the combined DE/DA analysis. A data frame named “combine” inside the list is the combined analysis. Rows are genes/drivers, columns are combined statistics (e.g. “logFC”, “AveExpr”, “t”, “P.Value” etc.). ## Third comparison: G4 vs. others # Combine the comparison results from `G4.Vs.WNT` and `G4.Vs.SHH` comp_name &lt;- &#39;G4.Vs.otherTwo&#39; # Each comparison must has a name DE_gene_comb &lt;- combineDE(DE_list=list(&#39;G4.Vs.WNT&#39;=analysis.par$DE$`G4.Vs.WNT`,&#39;G4.Vs.SHH&#39;=analysis.par$DE$`G4.Vs.SHH`)) DA_driver_comb &lt;- combineDE(DE_list=list(&#39;G4.Vs.WNT&#39;=analysis.par$DA$`G4.Vs.WNT`,&#39;G4.Vs.SHH&#39;=analysis.par$DA$`G4.Vs.SHH`)) analysis.par$DE[[comp_name]] &lt;- DE_gene_comb$combine analysis.par$DA[[comp_name]] &lt;- DA_driver_comb$combine NetBID2 also provides draw.combineDE() to visualize the top drivers with significant DE/DA from the combined comparison, with DE/DA values from seperate comparisons listed as well. Drivers are sorted based on the P-values from the third column, which is the combined comparison (G4 vs. WNT+SHH). Driver table of top DE: # Driver table of top DE draw.combineDE(DE_gene_comb) draw.combineDE(DE_gene_comb,pdf_file=sprintf(&#39;%s/combineDE.pdf&#39;,analysis.par$out.dir.PLOT)) # Save it as PDF Driver table of top DA: # Driver table of top DA draw.combineDE(DA_driver_comb) draw.combineDE(DA_driver_comb,pdf_file=sprintf(&#39;%s/combineDA.pdf&#39;,analysis.par$out.dir.PLOT)) # Save it as PDF Another way to perform the comparison between one group versus multiple groups, is to choose the sample names from multiple groups as G0_name parameter in the getDE.BID.2G(). In this way, the user doesn’t need to call combineDE. But the final result may vary, due to the different statistical hypothesis. # Another way to do the third comparison: G4 vs. others comp_name &lt;- &#39;G4.Vs.others&#39; # Get sample names from each compared group phe_info &lt;- pData(analysis.par$cal.eset) G1 &lt;- rownames(phe_info)[which(phe_info$`subgroup`==&#39;G4&#39;)] # Experiment group G0 &lt;- rownames(phe_info)[which(phe_info$`subgroup`!=&#39;G4&#39;)] # Combine other groups as the Control group DE_gene_bid &lt;- getDE.BID.2G(eset=analysis.par$cal.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;others&#39;) DA_driver_bid &lt;- getDE.BID.2G(eset=analysis.par$merge.ac.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;others&#39;) # Save comparison result to list element in analysis.par, with comparison name analysis.par$DE[[comp_name]] &lt;- DE_gene_bid analysis.par$DA[[comp_name]] &lt;- DA_driver_bid Save the comparison results as RData. # Save Step 3 analysis.par as RData NetBID.saveRData(analysis.par=analysis.par,step=&#39;act-DA&#39;) Now, we have get the top differential expression (DE) and activity (DA) drivers from different comparisons. We can use draw.NetBID() to visualize the top drivers (top 30 by default). Here, the displayed statistics for NetBID is set at P.Value and logFC for differential expression (set by DA_display_col and DE_display_col). draw.NetBID(DA_list=analysis.par$DA,DE_list=analysis.par$DE,main_id=&#39;G4.Vs.others&#39;) draw.NetBID(DA_list=analysis.par$DA,DE_list=analysis.par$DE,main_id=&#39;G4.Vs.others&#39;,pdf_file=sprintf(&#39;%s/NetBID_TOP.pdf&#39;,analysis.par$out.dir.PLOT),text_cex=0.8) # Save as PDF Users can customize the table above, by choosing which column to display DE or DA, or by choosing which comparison to display. Step 4: Generate a master table for drivers (ms-tab) Purpose: gather previous calculated data to create a final master table for all possible drivers. Please skip the following line if you didn’t close R session after completed Step 1-3. Don’t skip, if you have checked out and closed R session after completed the Step 1-3. Before start Step 4, please reload analysis.par RData from Step 3. NetBID.loadRData() reloads RData saved by NetBID.saveRData(). It prevents user from repeating former pipeline steps. If the re-opened R session doesn’t have analysis.par in the environment, please comment off the first two command lines. It will create a temporary analysis.par with path of the saved Step 3 RData, analysis.par$out.dir.DATA. The path test//driver_2019-05-06//DATA/ here is just an example, users need to give their own path used to save analysis.par RData from Step 3. # Reload analysis.par RData from Step 3 #analysis.par &lt;- list() #analysis.par$out.dir.DATA &lt;- &#39;test//driver_2019-05-06//DATA/&#39; NetBID.loadRData(analysis.par=analysis.par,step=&#39;act-DA&#39;) To create the final master table, users need to gather certian previous data and pass them to the parameters in generate.masterTable() function. Here are the details, use_comp, the vector of multiple comparison names. It will be used as the columns of master table. If use all the comparisons, just call names(analysis.par$DE). DE and DA, if following the previous pipeline, just use analysis.par$DE and analysis.par$DA. network, the driver-to-target list. The names of the list elements are drivers. Each element is a data frame, usually contains three columns. “target”, target gene names; “MI”, mutual information; “spearman”, spearman correlation coefficient. If following the previous pipeline, just use analysis.par$merge.network$target_list. tf_sigs, contains all the detailed information of TF and Sig. Users need to call db.preload() for access. db.preload() reloads the TF/SIG gene lists into R workspace and saves it locally under db/ directory with specified species name and analysis level. z_col, name of the column in getDE.limma.2G() and getDE.BID.2G() output data frame contains the Z-statistics. By default, it is “Z-statistics”. display_col, other driver’s statistical values for display. This must columns from the getDE.limma.2G() and getDE.BID.2G() output data frame. For example, “logFC” and “P.Value”. main_id_type, the type of driver’s ID, IMPORTANT. It comes from the attribute name in biomaRt package. Such as “ensembl_gene_id”, “ensembl_gene_id_version”, “ensembl_transcript_id”, “ensembl_transcript_id_version” or “refseq_mrna”. For details, please heck ID conversion section. transfer_tab, the data frame for ID conversion. If NULL and main_id_type is not in the column names of tf_sigs, it will use the conversion table within the function. Users can also create their own ID conversion table. If user want to save it into analysis.par, we suggest to call get_IDtransfer2symbol2type() instead of get_IDtransfer() as the output of the former function could be used in more visualization functions (e.g draw.bubblePlot()). column_order_stratey, an option to order to the columns in the mater table. If set as type, the columns will be ordered by column type; If set as comp, the columns will be ordered by comparison. # Reload data into R workspace, and saves it locally under db/ directory with specified species name and analysis level. db.preload(use_level=&#39;gene&#39;,use_spe=&#39;human&#39;,update=FALSE) # Get all comparison names all_comp &lt;- names(analysis.par$DE) # Users can use index or name to get target ones # Prepare the conversion table (OPTIONAL) use_genes &lt;- unique(c(analysis.par$merge.network$network_dat$source.symbol,analysis.par$merge.network$network_dat$target.symbol)) transfer_tab &lt;- get_IDtransfer2symbol2type(from_type = &#39;external_gene_name&#39;,use_genes=use_genes) analysis.par$transfer_tab &lt;- transfer_tab # Creat the final master table analysis.par$final_ms_tab &lt;- generate.masterTable(use_comp=all_comp,DE=analysis.par$DE,DA=analysis.par$DA, target_list=analysis.par$merge.network$target_list, tf_sigs=tf_sigs,z_col=&#39;Z-statistics&#39;,display_col=c(&#39;logFC&#39;,&#39;P.Value&#39;), main_id_type=&#39;external_gene_name&#39;) Please note, there may exist some drivers with only activity values but no expression values. This is due to the fact that the network-construction dataset is different from the analysis dataset. Save the final master table as EXCEL file. NetBID2 provides out2excel() to save the master table as EXCEL, with multiple options to highlight interested data (e.g. marker genes, drivers with significant Z-values). For more options, please check ?out2excel(). Download the master table EXCEL file ms_tab.xlsx here to see. # Path and file name of the output EXCEL file out_file &lt;- sprintf(&#39;%s/%s_ms_tab.xlsx&#39;,analysis.par$out.dir.DATA,analysis.par$project.name) # Highlight marker genes mark_gene &lt;- list(WNT=c(&#39;WIF1&#39;,&#39;TNC&#39;,&#39;GAD1&#39;,&#39;DKK2&#39;,&#39;EMX2&#39;), SHH=c(&#39;PDLIM3&#39;,&#39;EYA1&#39;,&#39;HHIP&#39;,&#39;ATOH1&#39;,&#39;SFRP1&#39;), G4=c(&#39;KCNA1&#39;,&#39;EOMES&#39;,&#39;KHDRBS2&#39;,&#39;RBM24&#39;,&#39;UNC5D&#39;)) # Customize highlight color codes #mark_col &lt;- get.class.color(names(mark_gene)) # this randomly assign color codes mark_col &lt;- list(G4=&#39;green&#39;,&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;) # Save the final master table as EXCEL file out2excel(analysis.par$final_ms_tab,out.xlsx = out_file,mark_gene,mark_col) We’ve finished the driver estimation part of NetBID2. We need to save the analysis.par as RData, cause it contains all the important results of driver estimation. This is ESSENTIAL to run Advanced analysis part of NetBID2 and NetBID2 shiny server. The analysis.par list includes 13 elements (main.dir, project.name, out.dir, out.dir.QC, out.dir.DATA, out.dir.PLOT, merge.network, cal.eset, merge.ac.eset, DE, DA, final_ms_tab, transfer_tab). They will be used to run NetBID shiny server. # Save Step 4 analysis.par as RData, ESSENTIAL NetBID.saveRData(analysis.par=analysis.par,step=&#39;ms-tab&#39;) How to interpret and use the master table ? out2excel() can save multiple master tables as excel sheets in one EXCEL file. For one master table, it consists of three parts: For one master table, it consists of three parts: The first six columns are gene_label, geneSymbol, originalID, originalID_label, funcType and Size. gene_label is the driver’s gene symbol or transcript symbol, with suffix “_TF” or “_SIG” to show driver’s type. geneSymbol is the driver’s gene symbol or transcript symbol, without suffix. originalID is the original ID type used in network construction, which should match the ID type in analysis.par$cal.eset, analysis.par$DE. originalID_label is the original ID type with suffix “_TF” or “_SIG”, which should match the the ID type in analysis.par$merge.network, analysis.par$merge.ac.eset,analysis.par$DA. originalID_label is the only column to ensure unique ID for row record. funcType is either “TF” or “SIG” to mark driver’s type. Size is number of target genes for the driver. The statistical columns are named as prefix.comp_name_{DA or DE}. The prefix can be Z, P.Value, logFC or AveExpr to indicate which statistical value is stored. The comp_name is the comparison name. For example, Z.G4.Vs.WNT_DA means the Z-statistics of the differential activity (DA) calculated from comparison between phenotype G4 and phenotype WNT. The color shade of the background indicated the significance of Z-statistics. The next 13 columns (from ensembl_gene_id to refseq_mrna) are detailed information of genes. The last columns (optional) are the detailed information of marker genes, users use mark_strategy=&#39;add_column&#39; to set. Users can fileter drivers by target size, or sort the Z-statistics to get top significant drivers. NetBID2 also provides Advanced analysis for advanced analysis and visualization.",
    "url": "http://localhost:4000/docs/driver_estimation",
    "relUrl": "/docs/driver_estimation"
  },
  "4": {
    "id": "4",
    "title": "Overview",
    "content": "NetBID 2.0: Data-driven Network-based Bayesian Inference of Drivers Documentation and Guided Analyses Get started now View it on GitHub Overview NetBID is a data-driven system biology pipeline, using data-driven network-based Bayesian inference approach to find drivers from transcriptomics, proteomics and phosphoproteomics data, where the drivers can be either transcription facotrs (TF) or signaling factors (SIG). NetBID 2.0 is an upgraded version of NetBID 1.0 that has been published in Nature in 2018. NetBID 2.0 inherites all the main functions from NetBID 1.0, and provides many more functions and pipelines to perform advanced end-to-end analyses. More data processing functions: Expression matrix pre-processing and quality assessment SJARACNe-based network construction Activity calculation of drivers and gene sets Discovery of differential expressed genes and differential activated drivers Generation of the master table for drivers For more data processing functions, please check NetBID2 PDF manual More visualization functions: Unsupervised learning of samples, comparison between the predicted labels vs. the observed labels Display drivers with significance profiles and target genes Display selected drivers with more details and its sub-network structure For more visualization functions, please check NetBID PDF manual More supporting functions: Gene/transcript ID conversion Gene function enrichment analysis &amp; visualization Data and pipeline management For more supporting functions, please check NetBID PDF manual",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },
  "5": {
    "id": "5",
    "title": "Installation",
    "content": "Installation Dependencies R, version &gt;= 3.6.0 Pre-request R packages Install a released R package Download a released version from https://github.com/jyyulab/NetBID/releases and run: devtools::install_local(&#39;NetBID2_2.0.1.tar.gz&#39;) Install from github master branch Clone the repository and install locally: devtools::install(pkg=&#39;.&#39;,dependencies=TRUE) ## Install the package with dependencies. devtools::install_deps(pkg = &quot;.&quot;, dependencies = TRUE) ## Install package dependencies if needed. Install without cloning the repository library(devtools) library(BiocManager) # set repos, for R version 3.6.0, Bioconductor version 3.9 local({ r &lt;- getOption(&quot;repos&quot;) r[&quot;CRAN&quot;] &lt;- &quot;https://cran.rstudio.com/&quot; r[&quot;BioCsoft&quot;] &lt;- &quot;https://bioconductor.org/packages/3.9/bioc&quot; r[&quot;BioCann&quot;] &lt;- &quot;https://bioconductor.org/packages/3.9/data/annotation&quot; r[&quot;BioCexp&quot;] &lt;- &quot;https://bioconductor.org/packages/3.9/data/experiment&quot; options(repos = r) }) devtools::install_github(&quot;jyyulab/NetBID&quot;,ref=&#39;master&#39;,dependencies=&#39;Depends&#39;)",
    "url": "http://localhost:4000/docs/installation",
    "relUrl": "/docs/installation"
  },
  "6": {
    "id": "6",
    "title": "- Network construction",
    "content": "Network Construction The purpose of this part: create a gene regulatory network from transcriptome dataset. No “lazy mode” function available for this part. The most important function here is : SJAracne.prepare(), user could directly call this function if eset (an ExpressionSet class object), TF_list (list of transcription factor genes with ID match the main ID type in eset) and SIG_list (list of signaling factor genes with ID match the main ID type in eset) are well prepared. Others are mainly supporting functions for eset QC, ID conversion and etc. The complete step-by-step demo script for network construction can be found here, pipeline_network_demo1.R. Quick Navigation for this page Step 0: Preparations Step 1: Load in gene expression datasets for network construction (exp-load) Q&amp;A: The choice of expression dataset for network construction Q&amp;A: Input RNA-Seq dataset Q&amp;A: Input expression matrix not from GEO database Step 2: Normalization for the expression dataset (exp-QC) Q&amp;A: QC for RNA-Seq dataset Q&amp;A: Combine two datasets Step 3: Check sample cluster information, optional (exp-cluster) Step 4: Prepare files to run SJARACNe (sjaracne-prep) Q&amp;A: ID conversion Step 0: Preparations Purpose: create an organized working directory for the network construction step in NetBID2 analysis. Make sure you have NetBID2 package. library(NetBID2) Create directories and folders to save and organize your analysis results. We have designed a function NetBID.network.dir.create() to handle the working directories, so users can have a better data organization. This function needs users to define the main working directory project_main_dir and the project’s name project_name. To prevent previous project with the same project_main_dir and project_name from being rewrite, it is highly suggested to add a time tag to your project_name. # Define main working directory and project name project_main_dir &lt;- &#39;./test&#39; # user defined main directory for the project, one main directory could have multiple project folders, distinguished by project name. current_date &lt;- format(Sys.time(), &quot;%Y-%m-%d&quot;) # optional, if user like to add current date to name the project folder project_name &lt;- sprintf(&#39;project_%s&#39;,current_date) # project name for the project folders under main directory. NetBID.network.dir.create() creates a main working directory with a subdirectory of the project. It also automatically creates three subfolders (QC, DATA and SJAR) within the project folder. QC/, storing Quality Control related plots; DATA/, saving data in RData format; SJAR/, storing files needed for running SJAracne SJARACNe. It also returns a list object, here named network.par with directory information wrapped inside. This list is an ESSENTIAL varaible for network construction, all the important intermediate data generated later on will be wrapped inside. If the current environment already has this variable, the function will only report a warning message and return the existed network.par. # Create a hierarchcial working directory and return a list contains the hierarchcial working directory information # This list object (network.par) is an ESSENTIAL variable in network construction pipeline network.par &lt;- NetBID.network.dir.create(project_main_dir=project_main_dir,project_name=project_name) Step 1: Load in gene expression datasets for network construction (exp-load) Purpose: download the target expression profile and perform quality control analysis on the raw data. Here, we use GSE116028 microarray data from GEO as the demo dataset. (Check The choice of expression dataset for network construction for more details). Given the ID of GSE (GEO series) and GPL (GEO platform), load.exp.GEO() will download the corresponding expression dataset from GEO database. The data will be saved as eSet class object in the environment, and will also be saved as RData in the out.dir folder. To download gene annotation file, one need to set getGPL=TRUE. To prevent repetitive download instead of updating, one need to set update=FALSE, so load.exp.GEO() will reload the existed RData (in this demo, RData will be reload from DATA/GSE116028_GPL6480.RData) directly. # Download expression dataset from GEO, need to provide GSE ID and GPL ID net_eset &lt;- load.exp.GEO(out.dir=network.par$out.dir.DATA,GSE=&#39;GSE116028&#39;,GPL=&#39;GPL6480&#39;,getGPL=TRUE,update=FALSE) Optional: Directly looking at the probe expression value from the raw expression dataset is not much meaningful. update_eset.feature() allows users to reassign the featureData slot of ExpressionSet object based on user’s demand. For example, from probe IDs to gene IDs. Given the conversion table use_feature_info, from_feature and to_feature, this function will convert old IDs into new IDs using merge_method. # ID conversion, or merge transcript level to expression level, use_feature_info can be other dataframe instead of fData; optional; net_eset &lt;- update_eset.feature(use_eset=net_eset,use_feature_info=fData(net_eset),from_feature=&#39;ID&#39;,to_feature=&#39;GENE_SYMBOL&#39;,merge_method=&#39;median&#39;) Optional: Users can use update_eset.phenotype() to extract interested phenotype information from phenoData slot of ExpressionSet object, and update it. Use use_col to tell the function which column(s) in use_phenotype_info to keep. If set to auto, it only extracting “cluster-meaningful” sample features (e.g. it is meaningless to use “gender”” as clustering feature, if all samples are female). If set to GEO-auto, it will extract columns: “geo_accession””, “title”, “source_name_ch1” and columns names ended with “:ch1”. # Select phenotype columns or user added phenotype info; optional net_eset &lt;- update_eset.phenotype(use_eset=net_eset,use_phenotype_info=pData(net_eset),use_sample_col=&#39;geo_accession&#39;,use_col=&#39;GEO-auto&#39;) Now, wrap this ExpressionSet object net_eset into the ESSENTIAL variable network.par. # Add the variable into network.par. ESSENTIAL STEP. network.par$net.eset &lt;- net_eset Perform quality control for the raw ExpressionSet object. Call draw.eset.QC(), an HTML report containing quality control analysis plots will be created. Users can choose interested phenotype information from phenoData slot to do this quality control, by assigning value to intgroup. If intgroup is NULL, all the columns from phenoData slot will be used. The HTML created by draw.eset.QC() is using pandoc. Please make sure you have it installed. Checking the availability of pandoc, one can call pandoc_available(). Installing and setting the environment for pandoc, one can call Sys.setenv(RSTUDIO_PANDOC=$installed_path), here replace $installed_path with the installed path of pandoc. If pandoc not available, users could set generate_html=FALSE and plots in pdf format will be generated. # QC for the raw eset draw.eset.QC(network.par$net.eset,outdir=network.par$out.dir.QC,intgroup=NULL,do.logtransform=FALSE,prefix=&#39;beforeQC_&#39;, pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;),pca_plot_type=&#39;2D.interactive&#39;) - What information can you get from the HTML QC report? (before_QC.html) A table. It contains phenotype information of samples. Descriptive variables, such as number of samples and genes (probes/transcripts/…); A heatmap and a PCA biplot. All samples will be clustered using the raw expression values across all the genes as features. The aim of this is to check possible mis-labeled samples and the occurrence of batch effects; A correlation plot for all sample pairs. This helps to check the correlation within group and between groups. A density plot. It shows the range and the distribution of the expression values. This also helps to judge if the original dataset has been log transformed; Now, the basic pre-processing steps are done for the raw data. For persistent storage of data, and prevent the re-run of all previous steps. Users can checkout and save network.par as RData for this part. The function NetBID.saveRData() provide easier pipeline step checkout and reference. Giving pipeline step name to step, the network.par will be saved with step name as network.par$out.dir.DATA/network.par.Step.{exp-load}.RData. # Save Step 1 network.par as RData NetBID.saveRData(network.par = network.par,step=&#39;exp-load&#39;) The choice of expression data set for network construction For a NetBID2 project, users need to decide what expression dataset to use for starting their biological story. Here are some important factors need to be considered, when using the expression dataset to construct regulatory network. The reasoning of using expression dataset to infer gene regulatory network is based on SJARACNe. It uses the information-theoretic approach to eliminate the majority of indirect interactions inferred by co-expression methods. The more samples, the higher sensitivity and precision. Typically, more than 100 samples is recommended. Large size public datasets from the same tissue, cell line or biological background are recommended to use as the expression datasets. Users can search through public databases, such as GEO and TCGA. Computationally inferred networks cannot avoid to have false positive edges. Especially for edges with relatively low mutual information (MI) scores. Functional interpretation from the regulatory network will be explained in the Driver estimation part. In real-world practice, the demo’s expression dataset is too small to construct a high quality network. However, it provides a handy visualization for the procedure of the NetBID2. Input RNA-Seq dataset NetBID2 provides two functions to load expression dataset from RNA-Seq, load.exp.RNASeq.demo() and load.exp.RNASeq.demoSalmon(). BUT these two function are still in demo version, and don’t support the complicated options in tximport() and DESeq(). It’s challenging due to the various output format from RNA-Seq (e.g. using different reference genomes). We suggest to use those well-developped tools in this case. If users like to try load.exp.RNASeq.demo() and load.exp.RNASeq.demoSalmon(), be aware to the return_type in these functions. ‘txi’ is the output of tximport(). It is a list containing three matrices, abundance, counts and length. “counts” is the matrix of raw count. ‘counts’ is the matrix of raw count. ‘tpm’ is the raw tpm. ‘fpm’, ‘cpm’ is the fragments/counts per million mapped fragments. ‘raw-dds’ is the DESeqDataSet class object, which is the original one without processing. ‘dds’ is the DESeqDataSet class object, which is processed by DESeq(). ‘eset’ is the ExpressionSet class object, which is processed by DESeq() and vst(). Default is ‘tpm’. If users don’t choose ‘eset’ as return type. The output object cannot be directly used in the rest pipeline so far. Please check the Input expression matrix not from GEO database section to see how to proceed. Input expression matrix not from GEO database If users have expression matrix not obtained from GEO database. They still can prepared the ExpressionSet class object using generate.eset(). For example, RNA-Seq dataset processed into TPM (transcripts per million). #tpm &lt;- load.exp.RNASeq.demo(XXX) tmp_mat &lt;- log2(tpm) tmp_eset &lt;- generate.eset(exp_mat = tmp_mat, phenotype_info = NULL,feature_info = NULL, annotation_info = &quot;&quot;) Some details of generate.eset(): it generates ExpressionSet class object to contain and describe the high-throughput assays; Users can define its slots, which are expression matrix (required), phenotype information and feature information (optional); If phenotype_info = NULL, a column named with ‘group’ will be automatically generated; If feature_info = NULL, a column named with ‘gene’ will be automatically generated. Step 2: Normalization for the expression dataset (exp-QC) Purpose: normalize the expression data and perform quality control analysis on the normalized data. Please skip the following line if you didn’t close R session after completed Step 1. Don’t skip, if you have checked out and closed R session after completed the Step 1. Before start Step 2, please reload network.par RData from Step 1. NetBID.loadRData() reloads RData saved by NetBID.saveRData(). It prevents user from repeating former pipeline steps. If the re-opened R session doesn’t have network.par in the environment, please comment off the first two command lines. It will create a temporary network.par with path of the saved Step 1 RData, network.par$out.dir.DATA. The path test//project_2019-05-02//DATA/ here is just an example, users need to give their own path used to save network.par RData from Step 1. # Reload network.par RData from Step 1 #network.par &lt;- list() #network.par$out.dir.DATA &lt;- &#39;test//project_2019-05-02//DATA/&#39; NetBID.loadRData(network.par = network.par,step=&#39;exp-load&#39;) The following QC steps are highly suggested for microarray dataset, but not essential. First, the handling of missing data. Count the number of NA values for each sample and each gene (or probes/transcripts/…). If one sample or gene has too many NA values, user can choose to remove that sample or gene, or perform imputation by using impute.knn(). # Get the expression matrix from ExpressionSet object mat &lt;- exprs(network.par$net.eset) # Count and show number of NAs across samples and genes sample_na_count &lt;- apply(mat,1,function(x){length(which(is.na(x)==TRUE))}) print(table(sample_na_count)) gene_na_count &lt;- apply(mat,2,function(x){length(which(is.na(x)==TRUE))}) print(table(gene_na_count)) # Perform imputation if(sum(sample_na_count)+sum(gene_na_count)&gt;0) mat &lt;- impute.knn(mat)$data Second, the log2 transformation. Sometimes it is hard to know whether the raw dataset has been log2-transformed or not. Here, we use a threshold from experience to check the median value. It may not be suitable for all cases, users can modify the threshold based on their own experience. # Perform log2 transformation med_val &lt;- median(apply(mat,2,median)); print(med_val) if(med_val&gt;16){mat &lt;- log2(mat)} Third, the quantile normalization across samples. This is suggested for dealing with microarray dataset, but not for RNA-Seq or log2tpm etc. # Perform limma quantile normalization mat &lt;- normalizeQuantiles(mat) Fourth, filter out genes with very low expression values (bottom 5%) in most samples (more than 90%). The presence of low-expression genes are less informative for network construction. # Filter out low-expression genes choose1 &lt;- apply(mat&lt;= quantile(mat, probs = 0.05), 1, sum)&lt;= ncol(mat) * 0.90 print(table(choose1)) mat &lt;- mat[choose1,] Now, the expression matrix has been updated. Users need to wrap it into the ExpressionSet class object, so it can be used for later pipeline studies. generate.eset() is designed to create the ExpressionSet object when only expression matrix is available. Users can also update the network.par$net.eset, and generate the HTML QC report to the normalized data, and save it as RData. Please use draw.eset.QC() to create QC report and NetBID.saveRData() to save the normalized network.par. # Update eset with normalized expression matrix net_eset &lt;- generate.eset(exp_mat=mat, phenotype_info=pData(network.par$net.eset)[colnames(mat),], feature_info=fData(network.par$net.eset)[rownames(mat),], annotation_info=annotation(network.par$net.eset)) # Updata network.par with new eset network.par$net.eset &lt;- net_eset # QC for the normalized eset draw.eset.QC(network.par$net.eset,outdir=network.par$out.dir.QC,intgroup=NULL,do.logtransform=FALSE,prefix=&#39;afterQC_&#39;, pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;),pca_plot_type=&#39;2D.interactive&#39;) # Save Step 2 network.par as RData NetBID.saveRData(network.par = network.par,step=&#39;exp-QC&#39;) - What information can you get from the HTML QC report after QC steps? (after_QC.html) A table. Compare the table with the one in Step 1. To see if a large amount of genes/samples has been removed; A heatmap and a PCA biplot. All samples will be clustered using the normalized expression values across all the genes as features. The aim of this is to check possible mis-labeled samples; A correlation plot for all sample pairs. This helps to check the correlation within group and between groups. A density plot. Compare the table with the one in Step 1. To see if the low expressed genes have been removed; QC for RNA-Seq dataset QC Step 1 to Step 3 are not suitable for RNA-Seq dataset, regardless of their pre-processing strategies. Only QC Step 4, “removing low expressed genes” is suggested to perform. For example, if one uses load.exp.RNASeq.demo() or load.exp.RNASeq.demoSalmon() with settings of dds or eset. There is no need for normalization. If one uses the raw count data as the expression matrix, he can call RNASeqCount.normalize.scale() to perform normalizaiton, which is followed by “log2 transformation”. If one uses the FPKM (Fagments Per Kilobase Million), TPM (Transcripts Per Million), CPM (Counts Per Million), the “log2 transformation” from QC Step 2 is suggested. The quality control analysis is different from case to case, NetBID2 only provides functions and tools to faciliate users to make their own decisions. Following the calling softwares’ pipeline is strongly suggested. Combine two datasets To combine two expression datasets, please call merge_eset(). If the two expression datasets come from the same platform and contain the same gene list, no Z-transformation will be performed. Otherwise, Z-transformation is suggested to be performed before combining these two datasets. The merged ExpressionSet class object will include a new phenotype column set by group_col_name, this column is used to distinguish each sample’s original dataset. No batch effect will be removed during combination by default. It is strongly suggested to check the sample clustering results before trying to remove the batch (User could follow the pipeline in the following Step 3). Generally, batch effect exists for microarray dataset but not for RNA-Seq dataset with the same protocal. Step 3: Check sample cluster analysis, optional (exp-cluster) Purpose: check if the highly variable genes can be used to perform good sample cluster analysis (predicted labels vs. real labels). This step is not necessary to perform NetBID2. Just create plots for visualization, no modification to the data. Please skip the following line if you didn’t close R session after completed Step 1 and Step 2. Don’t skip, if you have checked out and closed R session after completed the Step 1 and Step 2. Before start Step 3, please reload network.par RData from Step 2. NetBID.loadRData() reloads RData saved by NetBID.saveRData(). It prevents user from repeating former pipeline steps. If the re-opened R session doesn’t have network.par in the environment, please comment off the first two command lines. It will create a temporary network.par with path of the saved Step 1 RData, network.par$out.dir.DATA. The path test//project_2019-05-02//DATA/ here is just an example, users need to give their own path used to save network.par RData from Step 2. # Reload network.par RData from Step 2 #network.par &lt;- list() #network.par$out.dir.DATA &lt;- &#39;test//project_2019-05-02//DATA/&#39; NetBID.loadRData(network.par = network.par,step=&#39;exp-QC&#39;) Select the most variable genes across samples using IQR.filter() to perform sample cluster analysis. IQR (interquartile range) is a measure of statistical dispersion. It is calculated for each gene across all the samples. IQR.filter extract top 50% variable genes from the expression matrix by setting thre to 0.5. Users can also set a list of interested genes loose_gene to pass a less stringent filter, by setting a looser threshold value to loose_thre. # Select the most variable genes across samples mat &lt;- exprs(network.par$net.eset) choose1 &lt;- IQR.filter(exp_mat=mat,use_genes=rownames(mat),thre = 0.5) print(table(choose1)) mat &lt;- mat[choose1,] To have a taste of how IQR filtered genes will affect the cluster analysis of samples. Wrap the filtered genes into a temporary ExpressionSet object and create a HTML QC report. Cluster_QC.html # Generate temporary eset tmp_net_eset &lt;- generate.eset(exp_mat=mat, phenotype_info=pData(network.par$net.eset)[colnames(mat),], feature_info=fData(network.par$net.eset)[rownames(mat),], annotation_info=annotation(network.par$net.eset)) # QC plot for IQR filtered eset draw.eset.QC(tmp_net_eset,outdir=network.par$out.dir.QC,intgroup=NULL,do.logtransform=FALSE,prefix=&#39;Cluster_&#39;, pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;),pca_plot_type=&#39;2D.interactive&#39;) The following scripts provide various ways to visualize and check if the IQR filter selected genes can be used to perform good sample cluster analysis (observed labels vs. predicted labels). Figures will be displayed instead of saving as files. First, extract “cluster-meaningful” phenotype columns. Each column of the phenotype information data frame pData(network.par$net.eset) can contain certain categories. For example, the “gender” column in the phenotype data frame, it has two categories, “Male” and “Female”. This categorial information gives the observed labels to samples. If users don’t know which phenotype columns to extract, get_int_group will extract all “cluster-meaningful” phenotype columns from the ExpressionSet object. For example, if “gender” column only contains “Female”, it is meaningless to extract is to do cluster analysis, cause all samples will be clustered as one. Another example, if all samples have differnet age, it is meaningless to extract “age” column, cause all samples will be grouped separately. # Extract phenotype information data frame from eset phe &lt;- pData(network.par$net.eset) # Extract all &quot;cluster-meaningful&quot; phenotype columns intgroup &lt;- get_int_group(network.par$net.eset) Second, perform clustering analysis on all “cluster-meaningful” phenotype columns and draw plots. for each phenotype column in the intgroup, user can choose draw.pca.kmeans() or draw.umap.kmeans() to cluster samples and visualize the result between the observed label vs. the predicted label. The clustering is performed by K-means, and the result can be plotted using PCA biplot or UMAP (Uniform Manifold Approximation and Projection). User can also choose another clustering method, MICA, by calling draw.MICA(). All three functions can either return the K-value yielding the optimal result (setting return_type=&#39;optimal&#39;), or all the K-values (setting return_type=&#39;all&#39;) used for clustering. # Cluster analysis using Kmeans and plot result using PCA biplot (pca+kmeans in 2D) for(i in 1:length(intgroup)){ print(intgroup[i]) pred_label &lt;- draw.pca.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,intgroup[i]),pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) } Here, we pick the subgroup column from the demo’s phenotype data frame as an example, to show various visualization tools NetBID2 can provide. get_obs_label() returns a vector of selected phenotype descriptive information for each sample. use_int &lt;- &#39;subgroup&#39; pred_label &lt;- draw.pca.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,use_int),plot_type=&#39;2D&#39;,pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) Above is a side-by-side basic scatter plot of samples. The categories of observed labels (left figure) and predicted labels (right figure) are distinguished by color. The calculated statistics on top of the right figure quantifies the similarity between observed labels predicted labels. ARI is short for “adjusted rand index”, ranges from 0 to 1. Higher ARI value indicates higher similarity. For details, please check get_clustComp(). pred_label &lt;- draw.pca.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,use_int),plot_type=&#39;2D.ellipse&#39;,pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) Above is a side-by-side scatter plot with an ellipse drawn around each cluster of samples. Each ellipse is marked with its cluster label. pred_label &lt;- draw.pca.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,use_int),plot_type=&#39;3D&#39;,pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) Above is a side-by-side scatter plot in 3D. Here, we use the first three principle component as axises. print(table(list(pred_label=pred_label,obs_label=get_obs_label(phe, use_int)))) draw.clustComp(pred_label,obs_label=get_obs_label(phe,use_int),outlier_cex=1,low_K=10) Above is a table to visualize each sample’s observed label vs. its predicted label, it shows more details. The darker the table cell is, the more samples are gathered in the corresponding label. We can see 4 WNTs can be further separated into two sub-groups. However, in this demo dataset, no obvious outlier samples are observed. draw.pca.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,use_int), plot_type=&#39;2D.interactive&#39;, pre_define=c(&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;,&#39;G4&#39;=&#39;green&#39;)) Above is the interactive plot, user could mouse over to check the sample label for each points. The text for each point is organized as “sample_name:observed_label:predicted_label”. The color to the points are categorized by the observed label and the shape by the predicted label. If user found an outlier sample and removed it, we suggest to re-run Step 2 and Step 3 to see whether the data got cleaner after the remove of outlier. Step 4: Prepare files to run SJARACNe (sjaracne-prep) Purpose: download SJARACNe needed database to local folders and prepare files to run SJARACNe. Please skip the following line if you didn’t close R session after completed Step 1 and Step 2 (doesn’t matter if you runned Step 3 or not). Don’t skip, if you have checked out and closed R session after completed the Step 1 and Step 2. Before start Step 4, please reload network.par RData from Step 2. NetBID.loadRData() reloads RData saved by NetBID.saveRData(). It prevents user from repeating former pipeline steps. If the re-opened R session doesn’t have network.par in the environment, please comment off the first two command lines. It will create a temporary network.par with path of the saved Step 1 RData, network.par$out.dir.DATA. The path test//project_2019-05-02//DATA/ here is just an example, users need to give their own path used to save network.par RData from Step 2. # Reload network.par RData from Step 2 #network.par &lt;- list() #network.par$out.dir.DATA &lt;- &#39;test//project_2019-05-02//DATA/&#39; NetBID.loadRData(network.par = network.par,step=&#39;exp-QC&#39;) First, use db.preload() to download the transcription facotrs (TF) list and signaling factors (SIG) list, with species and level defined. For the TF and SIG list, NetBID2 has external_gene_name and ensembl_gene_id ID type files for human and mouse embedded in the package. (e.g. MOUSE_SIG_ensembl_gene_id.txt in system.file(package = &quot;NetBID2&quot;)/db/). To use these files, just set TF_list=NULL or SIG_list=NULL. If users would like to use their own list, please pass them to TF_list=NULL or SIG_list=NULL. For the species and level, NetBID2 has prepared both “gene-level”” and “transcript-level” RData for human by default. If the target species is not human, user can set use_spe to target species, and db.preload() will prepare that species database. For the storage of downloaded data, if user leaves main.dir=NULL, the RData will be saved automatically to system.file(package = &quot;NetBID2&quot;)/db/. If NetBID2 is installed in a public place and user doesn’t have the root permissions, one can set main.dir to another path with permission. And please make sure to use the same path for the further analysis. # Load database db.preload(use_level=&#39;gene&#39;,use_spe=&#39;human&#39;,update=FALSE) Second, converts gene ID into the corresponding TF/SIG list, with selected gene/transcript type. Users can set use_gene_type in the function get.TF_SIG.list() to pick the attribute name to convert to. Options are, “ensembl_gene_id”, “ensembl_gene_id_version”, “ensembl_transcript_id”, “ensembl_transcript_id_version” and “refseq_mrna”. For details, please check ID conversion section below. Conversion is not required, if user can get the TF_list and SIG_list with the same ID type as in the expression matrix. In this case, users can jump to the final step to call SJAracne.prepare(). # Converts gene ID into the corresponding TF/SIG list use_gene_type &lt;- &#39;external_gene_name&#39; # user-defined use_genes &lt;- rownames(fData(network.par$net.eset)) use_list &lt;- get.TF_SIG.list(use_genes,use_gene_type=use_gene_type) Last, use SJAracne.prepare() to prepare files for running SJARACNe. For sample selection: user can choose to use all the samples or some of them. Here we use all the samples. For creating multiple networks: user can set prj.name for easier reference. For example, if user wants to create Group4 specific network using Group4 samples. Just specify use.samples and prj.name = &#39;Group4_net&#39;. This prj.name setting is important for the Driver estimation part. For other parameters: the IQR.thre and IQR.loose_thre will be passed to IQR.filter(). The loose_gene will be the genes in TF_list and SIG_list, which pre-defined as the possible drivers during network construction. For output file size: here in the demo, in order to control the file size, we set IQR.thre=0.9 and IQR.loose_thre=0.7. However, in real practice, IQR.thre=0.5 and IQR.loose_thre=0.1 is recommended. # Select samples for analysis phe &lt;- pData(network.par$net.eset) use.samples &lt;- rownames(phe) # here is using all samples, users can modify prj.name &lt;- network.par$project.name # if use different samples, need to change the project name SJAracne.prepare(eset=network.par$net.eset,use.samples=use.samples, TF_list=use_list$tf,SIG_list=use_list$sig, IQR.thre = 0.5,IQR.loose_thre = 0.1, SJAR.project_name=prj.name,SJAR.main_dir=network.par$out.dir.SJAR) Due to the memory consumption and speed computational capability, SJARACNe will handle the network construction, please follow the github tutorial to run SJARACNe. ID conversion We use the ID conversion tools from biomaRt. The ID names with different types (e.g gene symbols) or ID related attributes (e.g gene biotype) in biomaRt package, are the values we are interested in to retrieve. The commonly used ID types are “external_gene_name”,”ensembl_gene_id”, “ensembl_gene_id_version”, “ensembl_transcript_id”, “ensembl_transcript_id_version” and “refseq_mrna”. The listAttributes() function displays all available attributes in the selected dataset. ATTENTION biomaRt will use the newest version number of GENCODE. Since all the ID conversion related functions db.preload(), get.TF_SIG.list(), get_IDtransfer(), get_IDtransfer2symbol2type() and get_IDtransfer_betweenSpecies() will access the archived database through website link, the version number of ensembl ID may vary from different runs. Users can set ignore_version=TRUE to ignore the version number for ensembl IDs. Functions like, get_IDtransfer(), get_IDtransfer2symbol2type() and get_IDtransfer_betweenSpecies() can generate the conversion table for get_name_transfertab(). However, users can choose to use their own curated one.",
    "url": "http://localhost:4000/docs/network_construction",
    "relUrl": "/docs/network_construction"
  },
  "7": {
    "id": "7",
    "title": "Pre-requested",
    "content": "Pre-requested R packages R version &gt;= 3.6.0 Following is the description for dependent R packages, mainly for developers to better understand the code in NetBID2. Users do not need to digest the information below. R package Functions1 Category Purpose Biobase - Data processing ExpressionSet class GEOquery getGEO Data processing Get expression dataset from GEO database limma - Data processing Expression data normalization impute impute.knn Data processing Data imputation tximport Data processing Data import   DESeq2 DESeqDataSetFromTximport,DESeq Data processing Data import from txi and normalization for RNASeq data ConsensusClusterPlus - Clustering Get consensus clustering results aricode clustComp Clustering For cluster comparison statistic calculation igraph - Visualization Igraph class and basic network-based calculation RColorBrewer brewer.pal Visualization Get color bar plot3D scatter3D Visualization 3D plot plotrix draw.ellipse Visualization drawing ellipse umap umap Visualization data dimension reduction and visualization ComplexHeatmap Heatmap Visualization heatmap drawing plotly - Visualization For interactive plot ordinal clm,clmm bid Cumulative Link Mixed Models MCMCglmm MCMCglmm bid Multivariate Generalized Linear Mixed Models arm bayesglm bid Bayesian generalized linear models reshape melt bid Melt an object into a form suitable for easy casting biomaRt - ID conversion ID conversion GSVA gsva Gene Set gene set activity calculation msigdbr - Gene Set MSigDB database openxlsx - IO Output into excel file (master table) rhdf5 H5Fopen,H5Fclose IO For hd5 formation data processing (MICA) rmarkdown render Report For generating html report file kableExtra - Report For table layout in the report file ’-‘ in the Function column represents multiple functions in the package were used in NetBID2. &#8617;",
    "url": "http://localhost:4000/docs/pre_request",
    "relUrl": "/docs/pre_request"
  },
  "8": {
    "id": "8",
    "title": "User Guide",
    "content": "User guide Design manual The manual of all the NetBID functions is linked here NetBID_manual.pdf. Every function has its own demo scripts to demonstrate its functionality. All these 70 functions can be grouped into their corresponding function modules, Here are 4 functions we think are ESSENTIAL for the NetBID pipeline management: NetBID.network.dir.create() helps users to create an organized working directory for the network construction step in NetBID analysis. It creates a hierarchcial working directory and returns a list containing this directory information. NetBID.analysis.dir.create() helps users to create an organized working directory for the driver estimation step in NetBID analysis. It also creates a hierarchcial working directory and returns a list contains this directory information. NetBID.saveRData() helps users to save complicated list object generated by certain steps of NetBID’s pipeline. This function makes an easier data/pipeline management and reference. NetBID.loadRData() pairs with NetBID.saveRData(), it reloads previous saved Rdata, so users don’t need to re-run everything. Here are 2 list objects we think are ESSENTIAL for the NetBID pipeline analysis: network.par is a variable in the network construction part. It is created by NetBID.network.dir.create() with network construction directory information wrapped inside. This list object is used to store all the important results from the network construction pipeline. It can be saved as RData and reloaded back using NetBID.saveRData() and NetBID.loadRData(). analysis.par is a variable in the driver analysis part. It is created by NetBID.analysis.dir.create() with driver estimation directory information wrapped inside. This list object is used to store all the important results from the driver estimation pipeline. It also can be saved as RData and reloaded back using NetBID.saveRData() and NetBID.loadRData(). The workflow of each NetBID pipeline is summarized in the figure below, We highly suggest new users to follow the pipeline for driver analysis and visualization. Details of the NetBID pipeline is shown and explained using a demo dataset in the following tutorial. Of course, most functions in NetBID are still flexible to use and perform specific needs for users. Tutorial We choose the demo dataset from GEO database: GSE116028. This microarray dataset contains 13 adult medulloblastoma (MB) samples. Three phenotype subgroups of adult MB have been identified from distinguishabled expression profiles, clinical features, pathological features and prognosis. These subgroups together with their sample numbers are, 3 SHH, 4 WNT, and 6 Group4. Group4 tumors in adult have significantly worse progression-free and overall survival, compared to other molecular subtypes of tumor. Here, the goal is to find potential drivers in Group4 compared to other subtypes using NetBID. This may relate to specific clinical feature of Group4 MB subtype. Though the dataset in the tutorial is microarray, NetBID is also capable to analyze RNA-Seq data. We will show in the tutorial below as well. The tutorial contains three main parts, they can be followed by order or used independently: Network construction Driver estimation (master table generation) Advanced analysis (result visualization)",
    "url": "http://localhost:4000/docs/user_guide",
    "relUrl": "/docs/user_guide"
  }
  
}
